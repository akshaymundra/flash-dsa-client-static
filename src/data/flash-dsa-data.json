[
  {
    "sign_no": 1,
    "question": "Given an array ‘arr’ of size ‘n’ find the largest element in the array.",
    "name": "Largest Element in an Array",
    "topic": "array",
    "level": "easy",
    "url": "https://bit.ly/3Pld280",
    "approach": "",
    "pseudo_code": ""
  },
  {
    "sign_no": 2,
    "question": "You have been given an array ‘a’ of ‘n’ unique non-negative integers.\n\n\nFind the second largest and second smallest element from the array.\n\n\nReturn the two elements (second largest and second smallest) as another array of size 2.",
    "name": "Second Largest Element in an Array without sorting",
    "topic": "array",
    "level": "easy",
    "url": "https://bit.ly/3pFvBcN",
    "approach": "use variables to find out the largest, 2nd largest and similer for smallest too using Time complexity of O(n)...if u sort the TC = O(nlogn)",
    "pseudo_code": ""
  },
  {
    "sign_no": 3,
    "question": "You have been given an array ‘a’ of ‘n’ non-negative integers.You have to check whether the given array is sorted in the non-decreasing order or not.\n\n\nYour task is to return 1 if the given array is sorted. Else, return 0.",
    "name": "Check if the array is sorted",
    "topic": "array",
    "level": "easy",
    "url": "https://leetcode.com/problems/check-if-array-is-sorted-and-rotated/#:~:text=Input%3A%20nums%20%3D%20%5B2%2C,no%20rotation)%20to%20make%20nums.",
    "approach": "",
    "pseudo_code": ""
  },
  {
    "sign_no": 4,
    "question": "You are given a sorted integer array 'arr' of size 'n'.\nYou need to remove the duplicates from the array such that each element appears only once.\nReturn the length of this new array.",
    "name": "Remove duplicates from Sorted array",
    "topic": "array",
    "level": "easy",
    "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/#:~:text=Input%3A%20nums%20%3D%20%5B0%2C,%2C%203%2C%20and%204%20respectively.",
    "approach": "",
    "pseudo_code": ""
  },
  {
    "sign_no": 5,
    "question": "Given an array 'arr' containing 'n' elements, rotate this array left once and return it.\nRotating the array left by one means shifting all elements by one place to the \nleft and moving the first element to the last position in the array.",
    "name": "Left Rotate an array by one place",
    "topic": "array",
    "level": "easy",
    "url": "https://leetcode.com/problems/rotate-array/",
    "approach": "swap i to i+1 n times to get single left rotation",
    "pseudo_code": "Function rotateArray(arr, n):\n    For i from 0 to n-2:\n        Swap arr[i] with arr[i+1]\n\n    Return arr"
  },
  {
    "sign_no": 6,
    "question": "Given an array 'arr' with 'n' elements, the task is to rotate the array to the left by 'k' steps, where 'k' is non-negative.",
    "name": "Left rotate an array by D places",
    "topic": "array",
    "level": "easy",
    "url": "https://leetcode.com/problems/rotate-array/",
    "approach": "1. swap i to i+1 k*n times or 2. for left rotation -> ans[(i-k+n)%n] = arr[i];\nfor right rotation -> ans[(i+k)%n] = arr[i];",
    "pseudo_code": "Function rotateArray(arr, k):\n    n = Length of arr\n    Initialize ans as a new array of size n\n\n    For i from 0 to n-1:\n        ans[(i - k + n) mod n] = arr[i]\n\n    Return ans"
  },
  {
    "sign_no": 7,
    "question": "Given an array 'arr' of 'n' non-negative integers, your task is to move all the zeros to the end of the array while keeping the non-zero elements at the start of the array in their original order. Return the modified array.",
    "name": "Move Zeros to end",
    "topic": "array",
    "level": "easy",
    "url": "https://leetcode.com/problems/move-zeroes/",
    "approach": "1. count all zeros then put them in back of new array.\n2. use two pointers i and j and swap all zeros at i to j such that all zeros go to back",
    "pseudo_code": "Function moveZeros(n, arr):\n    i = 0\n    j = 0\n\n    While i < n:\n        If arr[j] != 0:\n            j++\n            i++\n        Else if arr[j] == 0 and arr[i] == 0:\n            i++\n        Else:\n            Swap arr[i] with arr[j]\n        \n    Return arr"
  },
  {
    "sign_no": 8,
    "question": "Linear search",
    "name": "Linear Search",
    "topic": "array",
    "level": "easy",
    "url": "https://bit.ly/3KcpHcB",
    "approach": "",
    "pseudo_code": ""
  },
  {
    "sign_no": 9,
    "question": "Given two sorted arrays, ‘a’ and ‘b’, of size ‘n’ and ‘m’, respectively, return the union of the arrays.\nThe union of two sorted arrays can be defined as an array consisting of the common and the distinct elements of the two arrays. The final array should be sorted in ascending order.\nNote: 'a' and 'b' may contain duplicate elements, but the union array must contain unique elements",
    "name": "Find the Union",
    "topic": "array",
    "level": "medium",
    "url": "https://bit.ly/3Ap7Onp",
    "approach": "1. use vector and skip all duplicates and merge them\n2. use set then convert to vector\n3. use map then convert map to vector",
    "pseudo_code": "Function sortedArray(a, b):\n    ans = Empty array to store the merged sorted array\n    i = 0\n    j = 0\n    n = Length of array a\n    m = Length of array b\n    last = Undefined\n\n    While i < n and j < m:\n        While a[i] == last:\n            Increment i\n        While b[j] == last:\n            Increment j\n        \n        If i == n or j == m:\n            Break the loop\n\n        If a[i] < b[j]:\n            Append a[i] to ans\n            last = a[i]\n            Increment i\n        Else:\n            Append b[j] to ans\n            last = b[j]\n            Increment j\n    \n    While i < n:\n        While a[i] == last:\n            Increment i\n        If i == n:\n            Break the loop\n        Append a[i] to ans\n        last = a[i]\n        Increment i\n\n    While j < m:\n        While b[j] == last:\n            Increment j\n        If j == m:\n            Break the loop\n        Append b[j] to ans\n        last = b[j]\n        Increment j\n\n    Return ans"
  },
  {
    "sign_no": 10,
    "question": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.",
    "name": "Find missing number in an array",
    "topic": "array",
    "level": "easy",
    "url": "https://leetcode.com/problems/missing-number/",
    "approach": "sum of n natural numbers - sum of array will be our missing number",
    "pseudo_code": ""
  },
  {
    "sign_no": 11,
    "question": "The Road Department is planning to make some new traffic regulations. But to make the regulations they need to analyze the current situation of the traffic.\nThe traffic can be analyzed from an array 'VEHICLE' of length 'N' , which consists of ‘0’ if there is no vehicle at that point and ‘1’ if there is a vehicle at the point.\nUnfortunately the array ‘VEHICLE’ got corrupted as at most 'M' '1' got flipped to ‘0’.\nTraffic jam is defined as the length of consecutive vehicles on the road.\nThe Road Department wants to know the worst possible scenario for the traffic jam. Return the maximum possible length of the consecutive vehicles.",
    "name": "Maximum Consecutive Ones",
    "topic": "array",
    "level": "easy",
    "url": "https://leetcode.com/problems/max-consecutive-ones/",
    "approach": "use two pointer and count number of zeros in that window..if count > 0 then remove zeros from left and arrr[i] == 0 then count--;\nupdate the ans as max(ans, j-i+1);",
    "pseudo_code": "Function traffic(n, m, a):\n    left = 0\n    right = 0\n    ans = 0\n    count = 0\n\n    While right < n:\n        If a[right] == 0:\n            Increment count\n\n        While count > m:\n            If a[left] == 0:\n                Decrement count\n            Increment left\n\n        Update ans to be the maximum of ans and (right - left + 1)\n        Increment right\n\n    Return ans"
  },
  {
    "sign_no": 12,
    "question": "You are given a sorted array 'arr' of positive integers of size 'n'.\n\n\nIt contains each number exactly twice except for one number, which occurs exactly once.\n\n\nFind the number that occurs exactly once.",
    "name": "Find the number that appears once, and other numbers twice.",
    "topic": "array",
    "level": "medium",
    "url": "https://leetcode.com/problems/single-number/",
    "approach": "1 .use map to find out the freq for each element and return the element with freq 1.\n\n2. use xor to take xor of all array then the remaining xor will be the single elements bc a^a = 0 and 0^a = a;",
    "pseudo_code": ""
  },
  {
    "sign_no": 13,
    "question": "You are given an array 'a' of size 'n' and an integer 'k'.\n\n\nFind the length of the longest subarray of 'a' whose sum is equal to 'k'.",
    "name": "Longest subarray with given sum K(positives)",
    "topic": "array",
    "level": "medium",
    "url": "https://practice.geeksforgeeks.org/problems/longest-sub-array-with-sum-k0809/1?utm_source=youtube&utm_medium=collab_striver_ytdescription&utm_campaign=longest-sub-array-with-sum-k",
    "approach": "use two pointer and find sum..if sum > k them remove from left\n\nslliding window technique",
    "pseudo_code": "Function longestSubarrayWithSumK(a, k):\n    n = Length of array a\n    sum = a[0]\n    left = 0\n    right = 0\n    maxLen = 0\n\n    While right < n:\n        While left <= right and sum > k:\n            sum -= a[left]\n            Increment left\n\n        If sum == k:\n            maxLen = maximum of maxLen and (right - left + 1)\n\n        Increment right\n        If right < n:\n            sum += a[right]\n\n    Return maxLen"
  },
  {
    "sign_no": 14,
    "question": "Ninja and his friend are playing a game of subarrays. They have an array ‘NUMS’ of length ‘N’. Ninja’s friend gives him an arbitrary integer ‘K’ and asks him to find the length of the longest subarray in which the sum of elements is equal to ‘K’.\n\nNinjas asks for your help to win this game. Find the length of the longest subarray in which the sum of elements is equal to ‘K’.\n\nIf there is no subarray whose sum is ‘K’ then you should return 0.",
    "name": "Longest subarray with sum K (Positives + Negatives)",
    "topic": "array",
    "level": "medium",
    "url": "https://practice.geeksforgeeks.org/problems/longest-sub-array-with-sum-k0809/1?utm_source=youtube&utm_medium=collab_striver_ytdescription&utm_campaign=longest-sub-array-with-sum-k",
    "approach": "use two pointer and find sum..if sum > k them remove from left slliding window technique ",
    "pseudo_code": "Function longestSubarrayWithSumK(a, k):\n    n = Length of array a\n    sum = a[0]\n    left = 0\n    right = 0\n    maxLen = 0\n\n    While right < n:\n        While left <= right and sum > k:\n            sum -= a[left]\n            Increment left\n\n        If sum == k:\n            maxLen = maximum of maxLen and (right - left + 1)\n\n        Increment right\n        If right < n:\n            sum += a[right]\n\n    Return maxLen"
  },
  {
    "sign_no": 15,
    "question": "Sam want to read exactly ‘TARGET’ number of pages.\n\nHe has an array ‘BOOK’ containing the number of pages for ‘N’ books.\n\nReturn YES/NO, if it is possible for him to read any 2 books and he can meet his ‘TARGET’ number of pages.",
    "name": "2Sum Problem",
    "topic": "array",
    "level": "medium",
    "url": "https://leetcode.com/problems/two-sum/",
    "approach": "use two pointer-> i=0, j=n-1;\nif sum of a[i]+a[j] > target then j--, if less then i++ else we found the answer.",
    "pseudo_code": "Function read(n, book, target):\n    Sort book array in non-decreasing order\n    \n    left = 0\n    right = n - 1\n    \n    While left < right:\n        sum = book[left] + book[right]\n        If sum == target:\n            Return \"YES\"\n        Else If sum < target:\n            Increment left\n        Else:\n            Decrement right\n    \n    Return \"NO\""
  },
  {
    "sign_no": 16,
    "question": "You have been given an array/list 'arr' consisting of 'n' elements.\n\n\nEach element in the array is either 0, 1 or 2.\n\n\nSort this array/list in increasing order.\n\n\nDo not make a new array/list. Make changes in the given array/list.",
    "name": "Sort an array of 0's 1's and 2's",
    "topic": "array",
    "level": "medium",
    "url": "https://leetcode.com/problems/sort-colors/",
    "approach": "1. sort the array using inbuilt method.\n\n2. use three pointer..low, mid, high\nif mid == 0 swap with low and low++, mid++;\nif mid == 1 mid++;\nif mid == 2 then swap with high high--;",
    "pseudo_code": "Function sortArray(arr, n):\n    low = 0\n    mid = 0\n    high = n - 1\n\n    While mid <= high:\n        If arr[mid] == 0:\n            Swap arr[low] with arr[mid]\n            Increment low\n            Increment mid\n        Else If arr[mid] == 1:\n            Increment mid\n        Else:\n            Swap arr[high] with arr[mid]\n            Decrement high"
  },
  {
    "sign_no": 17,
    "question": "You are given an array 'a' of 'n' integers.\n\n\nA majority element in the array ‘a’ is an element that appears more than 'n' / 2 times.\n\n\nFind the majority element of the array.\n\n\nIt is guaranteed that the array 'a' always has a majority element.",
    "name": "Majority Element (>n/2 times)",
    "topic": "array",
    "level": "easy",
    "url": "https://leetcode.com/problems/majority-element/",
    "approach": "1. sort and retun [n/2];\n2. use heap;\n3. using Boyer-Moore Majority Voting Algorithm -> moore's voting algorithm",
    "pseudo_code": "Function majorityElement(a):\nInitialize ele to store the majority element\nInitialize count to keep track of the frequency of the majority element\n\nFor each element in array a:\nIf count is 0:\nSet ele to the current element\nSet count to 1\nElse if current element is equal to ele:\nIncrement count\nElse:\nDecrement count\n\nReturn ele"
  },
  {
    "sign_no": 18,
    "question": "You are given an array 'arr' of length 'n', consisting of integers.\n\n\nA subarray is a contiguous segment of an array. In other words, a subarray can be formed by removing 0 or more integers from the beginning and 0 or more integers from the end of an array.\n\n\nFind the sum of the subarray (including empty subarray) having maximum sum among all subarrays.\n\n\nThe sum of an empty subarray is 0.",
    "name": "Kadane's Algorithm, maximum subarray sum",
    "topic": "array",
    "level": "easy",
    "url": "https://leetcode.com/problems/maximum-subarray/",
    "approach": "1. find all sub arrays sum (not optimal)\n\n2. use kadane's algorithm",
    "pseudo_code": "Function maxSubarraySum(arr, n):\nInitialize maxi to store the maximum subarray sum found so far\nInitialize sum to keep track of the current subarray sum\n\nFor i from 0 to n-1:\nsum = maximum of 0 and (sum + arr[i])\nmaxi = maximum of maxi and sum\n\nReturn maxi"
  },
  {
    "sign_no": 19,
    "question": "You are given an array 'a' of size 'n' and an integer 'k'.\n\n\nFind the length of the longest subarray of 'a' whose sum is equal to 'k'.",
    "name": "Print subarray with maximum subarray sum (extended version of above problem)",
    "topic": "array",
    "level": "medium",
    "url": "https://bit.ly/3SLFFhs",
    "approach": "use 2 pointer sliding window approach and find max len;\nsum > k then sum-=a[left], left++;\nelse sum == k -> update maxlen;\nright++;",
    "pseudo_code": "Function longestSubarrayWithSumK(a, k):\nn = Length of array a\nsum = 0\nleft = 0\nright = 0\nmaxLen = 0\n\nWhile right < n:\nsum += a[right]\nWhile sum > k:\nsum -= a[left]\nIncrement left\nIf sum == k:\nmaxLen = maximum of maxLen and (right - left + 1)\nIncrement right\n\nReturn maxLen"
  },
  {
    "sign_no": 20,
    "question": "You are given an array of integers 'prices' of size 'n', where ‘prices[i]’ is the price of a given stock on an ‘i’-th day.\n\n\nYou want to maximize the profit by choosing a single day to buy one stock and a different day to sell that stock.\n\n\nPlease note that you can’t sell a stock before you buy one.\n\n\nReturn the maximum profit you can achieve from this transaction.",
    "name": "Stock Buy and Sell",
    "topic": "array",
    "level": "easy",
    "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
    "approach": "let buyprice be a[0];\nif current prices is lees then buy prices then update buy price to current price.\nelse max profit will be max of maxprofit and current price - buy price.",
    "pseudo_code": "Function bestTimeToBuyAndSellStock(prices):\nn = Length of prices\nmaxProfit = 0\nbuyPrice = prices[0]\n\nFor i from 1 to n-1:\nmaxProfit = maximum of maxProfit and (prices[i] - buyPrice)\nbuyPrice = minimum of buyPrice and prices[i]\n\nReturn maxProfit"
  },
  {
    "sign_no": 21,
    "question": "There is an array ‘A’ of size ‘N’ with an equal number of positive and negative elements.\n\nWithout altering the relative order of positive and negative numbers, you must return an array of alternative positive and negative values.\n\nNote:\n\nStart the array with a positive number. ",
    "name": "Rearrange the array in alternating positive and negative items",
    "topic": "array",
    "level": "medium",
    "url": "https://leetcode.com/problems/rearrange-array-elements-by-sign/",
    "approach": "take a new array of size n;\ntake 2 var index -> pos = 0 and neg = 1;\nif ar[i] < 0 then put it at neg index and neg = neg + 2;....\nsimiler for pos index.",
    "pseudo_code": "Function alternateNumbers(a):\nn = Length of array a\nInitialize ans as a new array of size n\n\nposIndex = 0\nnegIndex = 1\n\nFor i from 0 to n-1:\nIf a[i] < 0:\nans[negIndex] = a[i]\nIncrement negIndex by 2\nElse:\nans[posIndex] = a[i]\nIncrement posIndex by 2\n\nReturn ans"
  },
  {
    "sign_no": 22,
    "question": "You are given an array ‘a’ of ‘n’ integers.\n\n\nYou have to return the lexicographically next to greater permutation.\n\n\nNote:\n\nIf such a sequence is impossible, it must be rearranged in the lowest possible order.",
    "name": "Next Permutation",
    "topic": "array",
    "level": "medium",
    "url": "https://leetcode.com/problems/next-permutation/",
    "approach": "1. use inbuilt function of c++..next_permtation\n2. we can find the next permutation using the below algo\nfind the index from right which is lesses then its immediate right...a[j] < a[j+1] while j >= 0...if j becomes less then there is no such permutation exist.\nnow find and index i from right that is greater then a[j]..if found then break the loop and swap a[i] with a[j]...\nnow reverse the array from j+1 th position to end...\nthis will be our next greater permutation.",
    "pseudo_code": "Function nextGreaterPermutation(arr)\nInput: arr - an array of integers\nOutput: a vector containing the next greater permutation of the input array\n\nn = length of arr\nj = n - 2\n\n# Find the first index from the right where arr[j] < arr[j+1]\nwhile j >= 0 and arr[j] >= arr[j+1]\nj = j - 1\n\n# If no such index is found, the array is already in the largest possible permutation\nif j < 0\nSort arr in ascending order\nReturn arr\n\ni = n - 1\n\n# Find the rightmost element greater than arr[j]\nwhile arr[j] >= arr[i]\ni = i - 1\n\n# Swap arr[i] and arr[j]\nSwap arr[i] and arr[j]\n\nj = j + 1\ni = n - 1\n\n# Reverse the elements from index j to the end of the array\nwhile j < i\nSwap arr[j] and arr[i]\nj = j + 1\ni = i - 1\n\nReturn arr\nEnd Function"
  },
  {
    "sign_no": 23,
    "question": "There is an integer array ‘a’ of size ‘n’.\n\n\nAn element is called a Superior Element if it is greater than all the elements present to its right.\n\n\nYou must return an array all Superior Elements in the array ‘a’.\n\n\nNote:\n\nThe last element of the array is always a Superior Element",
    "name": "Leaders in an Array problem",
    "topic": "array",
    "level": "easy",
    "url": "https://bit.ly/3bZqbGc",
    "approach": "iterate through the array from right;\nonly push to new vector if its empty or the back of vector is < arr[i];\nthen the reverse of the new array will be out answer",
    "pseudo_code": "Function superiorElements(a):\nInitialize ans as an empty array\n\nn = Length of array a\n\nFor i from n-1 to 0 (decrementing order):\nIf ans is empty:\nAppend a[i] to ans\nElse If the last element of ans is less than a[i]:\nAppend a[i] to ans\n\nSort ans in non-decreasing order\n\nReturn ans"
  },
  {
    "sign_no": 24,
    "question": "There is an integer array ‘A’ of size ‘N’.\n\nA sequence is successive when the adjacent elements of the sequence have a difference of 1.\n\nYou must return the length of the longest successive sequence.\n\nNote:\n\nYou can reorder the array to form a sequence. ",
    "name": "Longest Consecutive Sequence in an Array",
    "topic": "array",
    "level": "medium",
    "url": "https://leetcode.com/problems/longest-consecutive-sequence/solution/",
    "approach": "sort the array...then find the sequence from start....so every next element is greater..like arr[i+1]-arr[i] == 1\nstore the prev elemenent in a seperate var as there will be duplicates also.....",
    "pseudo_code": "Function longestSuccessiveElements(a):\nSort array a in non-decreasing order\n\nn = Length of array a\nmaxLen = 0\nlen = 0\nprev = Negative Infinity\n\nFor i from 0 to n-1:\nIf a[i] - prev == 1:\nIncrement len\nElse If a[i] is not equal to prev:\nSet len to 1\nSet prev to a[i]\nUpdate maxLen to maximum of maxLen and len\n\nReturn maxLen"
  },
  {
    "sign_no": 25,
    "question": "You are given a matrix 'MATRIX' of dimension 'N' x 'M'. Your task is to make all the elements of row 'i' and column 'j' equal to 0 if any element in the ith row or jth column of the matrix is 0.\n\nNote:\n\n1) The number of rows should be at least 1.\n\n2) The number of columns should be at least 1.\n\n3) For example, refer to the below matrix illustration: ",
    "name": "Set Matrix Zeros",
    "topic": "array",
    "level": "medium",
    "url": "https://leetcode.com/problems/set-matrix-zeroes/",
    "approach": "take two new arrays row(n) and col(m) n and m are dimenstions.;\nif a[i][j] == 0 then put row[i] = 1 and col[i] =1;\n\nthen again iterate the matrix and if ...row[i] == 1 then put 0 at i,j;\nand if co[j] == 1 then also put 0 at [i][j];",
    "pseudo_code": "Function zeroMatrix(matrix, n, m):\nInitialize row as an array of size n filled with zeros\nInitialize col as an array of size m filled with zeros\n\n// Mark rows and columns containing zeros\nFor i from 0 to n-1:\nFor j from 0 to m-1:\nIf matrix[i][j] == 0:\nSet row[i] to 1\nSet col[j] to 1\n\n// Set elements to zero based on marked rows and columns\nFor i from 0 to n-1:\nFor j from 0 to m-1:\nIf row[i] == 1 or col[j] == 1:\nSet matrix[i][j] to 0\n\nReturn matrix"
  },
  {
    "sign_no": 26,
    "question": "You are given a square matrix ‘Mat’ of size ‘N’. You need to rotate ‘Mat’ by 90 degrees in the clockwise direction.\n\nNote:\n\nYou must rotate the matrix in place, i.e., you must modify the given matrix itself. You must not allocate another square matrix for rotation.\n\nFor example\n\nWhen,\n‘N’ = 2 and ‘Mat’ = {{1, 2}, {3, 4}}, we must modify ‘Mat’ to {{3, 1}, {4, 2}}.",
    "name": "Rotate Matrix by 90 degrees",
    "topic": "array",
    "level": "medium",
    "url": "https://leetcode.com/problems/rotate-image/",
    "approach": "take transpose of matrix and then reverse each row will give the matrix rotate to 90 degrees.",
    "pseudo_code": "Function rotateMatrix(mat):\nn = Size of mat (number of rows or columns)\n\n// Transpose the matrix\nFor i from 0 to n-1:\nFor j from 0 to i-1:\nSwap mat[i][j] with mat[j][i]\n\n// Reverse each row of the transposed matrix\nFor i from 0 to n-1:\nReverse mat[i]"
  },
  {
    "sign_no": 27,
    "question": "You are given a 2D matrix ‘MATRIX’ of ‘N’*’M’ dimension. You have to return the spiral traversal of the matrix.\n\nExample:\n\nInput:\nMATRIX = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60] ]\nOutput:\n1 3 5 7 20 60 34 30 23 10 11 16\n\nExplanation: Starting from the element in the first row and the first column, traverse from left to right (1 3 5 7), then top to bottom (20 60), then right to left (34 30 23), then bottom to up (10) and then left to right (11 16).",
    "name": "Print the matrix in spiral manner",
    "topic": "array",
    "level": "medium",
    "url": "https://leetcode.com/problems/spiral-matrix/",
    "approach": "",
    "pseudo_code": ""
  },
  {
    "sign_no": 28,
    "question": "You are given an integer array 'arr' of size 'N' and an integer 'K'.\n\nYour task is to find the total number of subarrays of the given array whose sum of elements is equal to k.\n\nA subarray is defined as a contiguous block of elements in the array.",
    "name": "Count subarrays with given sum",
    "topic": "array",
    "level": "easy",
    "url": "https://leetcode.com/problems/subarray-sum-equals-k/",
    "approach": "take two pointers left and right...if sum > k then remove from left;\nif sum == k then ans++;\n\n\non leetcode as there are negative numbers...we have to use prefix sum to solve this problem.",
    "pseudo_code": "Function findAllSubarraysWithGivenSum(arr, k):\nInitialize left = 0, right = 0\nInitialize n = Length of arr\nInitialize ans = 0\nInitialize sum = arr[0]\n\nWhile right < n:\nWhile left <= right and sum > k:\nsum -= arr[left]\nIncrement left\n\nIf sum == k:\nIncrement ans by 1\n\nIncrement right\nIf right < n:\nsum += arr[right]\n\nReturn ans"
  },
  {
    "sign_no": 29,
    "question": "You are given an integer ‘N’. You need to return the first ‘N’ rows of Pascal’s triangle.",
    "name": "Pascal's Triangle",
    "topic": "array",
    "level": "medium",
    "url": "https://leetcode.com/problems/pascals-triangle/",
    "approach": "",
    "pseudo_code": ""
  },
  {
    "sign_no": 30,
    "question": "Given an array ‘A’ of ‘N’ integers, find the majority elements of the array.\n\nA majority element in an array ‘A’ of size ‘N’ is an element that appears more than floor(N / 3) times.\n\nNote: The floor function returns the number rounded down to the nearest integer.\n\nNote: Return the array of majority elements in sorted order.",
    "name": "Majority Element (n/3 times)",
    "topic": "array",
    "level": "medium",
    "url": "https://leetcode.com/problems/majority-element-ii/",
    "approach": "use map to store the freq of each element then put the elements with freq > n/3 to a ans array",
    "pseudo_code": "Function majorityElement(v):\nInitialize an empty map mpp to store the frequency of elements\nInitialize an empty vector ans to store the majority elements\n\nn = Length of vector v\n\n// Count the frequency of each element\nFor each element x in v:\nIncrement mpp[x] by 1\n\n// Check if the frequency of any element is greater than n/3\nFor each element x and its frequency freq in mpp:\nIf freq is greater than n/3:\nAppend x to ans\n\nReturn ans"
  },
  {
    "sign_no": 31,
    "question": "You are given an array ‘ARR’ containing ‘N’ integers.\n\n\nReturn all the unique triplets [ARR[i], ARR[j], ARR[k]] such that i != j, j != k and k != i and their sum is equal to zero.",
    "name": "3-Sum Problem",
    "topic": "array",
    "level": "medium",
    "url": "https://leetcode.com/problems/3sum/",
    "approach": "take three pointers..i,j,k such that i will be out 1st number then we will find the remaining number;\nj=i+1 and k = n-1;\nsum = a[i]+a[j]+a[k]...if sum < 0 then j++ else sum > 0 k-- else push the triplet i,j,k and increase the j and k by 1;\nthen we will remove the duplicates for j and k so our final answer contains all unique triplets.",
    "pseudo_code": "Function triplet(n, arr):\nInitialize an empty 2D vector ans to store the triplets\nSort the array arr in non-decreasing order\n\nFor i from 0 to n-1:\nIf i is not equal to 0 and arr[i] is equal to arr[i-1]:\nContinue to the next iteration\n\nInitialize j = i + 1\nInitialize k = n - 1\n\nWhile j < k:\nCalculate sum = arr[i] + arr[j] + arr[k]\n\nIf sum is less than zero:\nIncrement j by 1\nElse If sum is greater than zero:\nDecrement k by 1\nElse:\nAdd the triplet {arr[i], arr[j], arr[k]} to ans\nIncrement j by 1\nDecrement k by 1\n\n// Skip duplicate elements\nWhile j < k and arr[j] is equal to arr[j-1]:\nIncrement j by 1\nWhile j < k and arr[k] is equal to arr[k+1]:\nDecrement k by 1\n\nReturn ans"
  },
  {
    "sign_no": 32,
    "question": "You are given an array ‘NUMS’ of length ‘N’. You are also given an integer ‘TARGET’.\n\n\nReturn an array of all the unique quadruplets [ ‘NUMS[ a ]’, ‘NUMS[ b ]’, ‘NUMS[ c ]’, ‘NUMS[ d ]’ ] with the following conditions:\n\n\ni. 0 <= a, b, c, d < ‘N’ and a, b, c, and d are distinct.\n\nii. NUMS[ a ] + NUMS[ b ] + NUMS[ c ] +NUMS[ d ] = TARGET\n\n\nReturn the array in any order.",
    "name": "4-Sum Problem",
    "topic": "array",
    "level": "hard",
    "url": "https://leetcode.com/problems/4sum/",
    "approach": "",
    "pseudo_code": ""
  },
  {
    "sign_no": 33,
    "question": "Ninja is given an array ‘Arr’ of size ‘N’. You have to help him find the longest subarray of ‘Arr’, whose sum is 0. You must return the length of the longest subarray whose sum is 0.",
    "name": "Largest Subarray with 0 Sum",
    "topic": "array",
    "level": "medium",
    "url": "https://bit.ly/3w5QSzC",
    "approach": "to calculate the longest subarray with sum 0 we have to store pre sum in a un0rdered map;\nso at each step we will store (sum, i) only if sum is not present in map;\nwe store index as value to sum in map;\nif(map(sum)) then maxlen = max(maxlen , i - map[sum]);",
    "pseudo_code": "Function getLongestZeroSumSubarrayLength(arr):\nn = Length of arr\nInitialize an empty unordered map preSum to store the prefix sum and its index\nInitialize sum = 0 to store the current prefix sum\nInitialize maxLen = 0 to store the length of the longest subarray with zero sum\n\nFor i from 0 to n-1:\nAdd arr[i] to sum\n\nIf sum is equal to 0:\nUpdate maxLen to maximum of maxLen and (i+1)\n\nCalculate rem = sum\n\nIf rem exists in preSum:\nUpdate maxLen to maximum of maxLen and (i - preSum[rem])\n\nIf sum does not exist in preSum:\nAdd sum to preSum with value i\n\nReturn maxLen"
  },
  {
    "sign_no": 34,
    "question": "Given an array ‘A’ consisting of ‘N’ integers and an integer ‘B’, find the number of subarrays of array ‘A’ whose bitwise XOR( ⊕ ) of all elements is equal to ‘B’.\n\n\nA subarray of an array is obtained by removing some(zero or more) elements from the front and back of the array.",
    "name": "Count number of subarrays with given xor K",
    "topic": "array",
    "level": "hard",
    "url": "https://www.interviewbit.com/problems/subarray-with-given-xor/",
    "approach": "use map to store the prefix xorr and its prequency;\nintution -> xor = xor^a[i];\nrem = xor^b;\nif we have rem in prefix map then we can say that the xor of elements between rem and xorr is b; so count += pref[rem];\nupdate the current xorr freq in prefix;",
    "pseudo_code": "Function subarraysWithSumK(a, b):\nn = Length of array a\nInitialize count = 0 to store the count of subarrays\nInitialize an empty map mpp to store the XOR prefix sum and its frequency\nInitialize xorr = 0 to store the current XOR prefix sum\nInsert xorr into mpp with frequency 1\n\nFor i from 0 to n-1:\nUpdate xorr to xorr XOR a[i]\nCalculate rem = xorr XOR b\nIncrement count by mpp[rem]\nIncrement the frequency of xorr in mpp by 1\n\nReturn count"
  },
  {
    "sign_no": 35,
    "question": "Ninja is playing with intervals. He has an array of intervals called ‘Arr’ having ‘N’ intervals.\n\n\nHowever, he doesn’t like overlapping intervals. So you must help Ninja by merging all the overlapping intervals in ‘Arr’ and return an array of non-overlapping intervals.\n\n\nNote:\n\nTwo intervals [L1, R1] and [L2, R2] such that L1 <= L2, are said to be overlapping if and only if L2 <= R1.",
    "name": "Merge Overlapping Subintervals",
    "topic": "array",
    "level": "medium",
    "url": "https://leetcode.com/problems/merge-intervals/",
    "approach": "sort array...then push intervals in array while checking if last interval of ans array is overlapping with the current interval then update the last interval present in aans array..if not then just push the current interval to the ans array.",
    "pseudo_code": "Function mergeOverlappingIntervals(arr):\nn = Length of arr\nInitialize an empty 2D vector ans to store the merged intervals\n\nSort the intervals in arr based on their start points\n\nFor each interval in arr:\nIf ans is not empty and the end point of the last interval in ans is greater than or equal to the start point of the current interval:\nUpdate the end point of the last interval in ans to the maximum of its current end point and the end point of the current interval\nElse:\nAppend the current interval to ans\n\nReturn ans"
  },
  {
    "sign_no": 36,
    "question": "Given two non-decreasing sorted arrays, ‘A’ and ‘B’, having ‘N’ and ‘M’ elements, respectively.\n\n\nYou must merge these arrays, ‘A’ and ‘B’, into a sorted array without using extra space. Of all the 'N + M' sorted elements, array 'A' should contain the first 'N' elements, and array 'B' should have the last 'M' elements.\n\n\nNote:\n\nYou must perform the merge operation in place and must not allocate any extra space to merge the two arrays.",
    "name": "Merge two sorted arrays without extra space",
    "topic": "array",
    "level": "medium",
    "url": "https://leetcode.com/problems/merge-sorted-array/",
    "approach": "take two pointers i = n-1 for array a and j=0 for b;\niterate through both while i>=0 and j < m;\nif( a[i] > b[j]) swap a,b;\nelse break;\nthen sort both array again;\nThe intution is that we put all the small elements from b to a which are less then elements of a so then we can sort both the arrau to get teh final answer.",
    "pseudo_code": "Function mergeTwoSortedArraysWithoutExtraSpace(a, b):\nn = Length of array a\nm = Length of array b\n\nInitialize i to n-1\nInitialize j to 0\n\nWhile i >= 0 and j < m:\nIf a[i] > b[j]:\nSwap a[i] and b[j]\nDecrement i by 1\nIncrement j by 1\nElse:\nBreak the loop\n\nSort array a in non-decreasing order\nSort array b in non-decreasing order"
  },
  {
    "sign_no": 37,
    "question": "You are given an array of ‘N’ integers where each integer value is between ‘1’ and ‘N’.\n\n\nEach integer appears exactly once except for ‘P’, which appears exactly twice, and ‘Q’, which is missing.\n\n\nYour task is to find ‘P’ and ‘Q’ and return them respectively.",
    "name": "Find the repeating and missing number",
    "topic": "array",
    "level": "hard",
    "url": "https://bit.ly/3zWZoCs",
    "approach": "1. using hash map we can find out the freq and fron this we can find out both the missing and repeating number.\n\n2. using math...let sum of 1to N be W and sum of squares of 1 to N be X;\nsimilerly sum of array be Z and sum of sq of aeray be Y;\nso, the difference of W - Z will also be difference of missing and repeating number = M - R = S1 ;\nand the diff of X-Y will be M2 - R2 = S2;\nso from above eq,\nM = (s1/s2 + s1) / 2;....putting r = m - s1\nR = M - s1;",
    "pseudo_code": "Function findMissingRepeatingNumbers(a):\nn = Length of array a\n\n// Calculate the sum of the first n natural numbers\nW = (n * (n + 1)) / 2\n\n// Calculate the sum of the squares of the first n natural numbers\nX = (n * (n + 1) * (2 * n + 1)) / 6\n\nInitialize variables missing and repeating\n\n// Iterate through the elements of the array\nFor each element x in a:\nSubtract x from W\nSubtract x^2 from X\n\n// Calculate the missing number using the formula\nmissing = ((X / W) + W) / 2\n\n// Calculate the repeating number by subtracting W from the missing number\nrepeating = missing - W\n\nReturn {repeating, missing}"
  },
  {
    "sign_no": 38,
    "question": "There is an integer array ‘A’ of size ‘N’.\n\n\nNumber of inversions in an array can be defined as the number of pairs of ‘i’, ‘j’ such that ‘i’ < ‘j’ and ‘A[i]’ > ‘A[j]’.\n\nYou must return the number of inversions in the array.",
    "name": "Count Inversions",
    "topic": "array",
    "level": "hard",
    "url": "https://bit.ly/3PtLWLM",
    "approach": "we can use brute force but it will give TLE;\n\nso we use merge sort concept dividing the array in small problems...\nnow we have low, mid, high..left = low, right = mid+1;...2 parts..\nas the left part is sorted and the right part is sorted by merge sort...and now while merging this two parts if a[left] > a[right] then its an inversion..however the array is sorted so all the elements after the left index are also inversion for a[right] so we have to count them too...so count += mid-left + 1;",
    "pseudo_code": "Function merge(a, low, mid, high):\nInitialize left to low and right to mid+1\nInitialize an empty temporary array temp\n\nWhile left <= mid and right <= high:\nIf a[left] <= a[right]:\nAppend a[left] to temp\nIncrement left by 1\nElse:\nAppend a[right] to temp\nIncrement right by 1\nIncrement cnt by (mid - left + 1)\n\nWhile left <= mid:\nAppend a[left] to temp\nIncrement left by 1\n\nWhile right <= high:\nAppend a[right] to temp\nIncrement right by 1\n\nFor i from low to high:\nAssign temp[i - low] to a[i]\n\nFunction mergeSort(a, low, high):\nIf low equals high, return\nCalculate mid as (low + high) / 2\n\nRecursively call mergeSort with arguments (a, low, mid)\nRecursively call mergeSort with arguments (a, mid+1, high)\nCall merge with arguments (a, low, mid, high)\n\nFunction numberOfInversions(a, n):\nCall mergeSort with arguments (a, 0, n-1)\nReturn cnt"
  },
  {
    "sign_no": 39,
    "question": "School is organizing a team contest. You are given an array ‘SKILL’ containing the skill level of ‘N’ candidates.\n\n\nTwo candidates(having index ‘i’ and ‘j’) can pair up to form a team if for index i < j, SKILL[i] > 2*SKILL[j].\n\nYour task is the return the count of all the possible pairs to take part in the contest.",
    "name": "Reverse Pairs",
    "topic": "array",
    "level": "hard",
    "url": "https://leetcode.com/problems/reverse-pairs/",
    "approach": "similer to prev problem...but as the condition says a[i] > 2*a[j] then we can't just use the merge function and change 1 line but instead we have t o tackle it seperately inside the merge function to count ",
    "pseudo_code": "Function merge(a, low, mid, high):\nInitialize left to low\nInitialize right to mid + 1\nInitialize an empty temporary array temp\n\nWhile left <= mid and right <= high:\nIf a[left] > 2 * a[right]:\nIncrement cnt by (mid - left + 1)\nIncrement right by 1\nElse:\nIncrement left by 1\n\nReset left to low\nReset right to mid + 1\n\nWhile left <= mid and right <= high:\nIf a[left] <= a[right]:\nAppend a[left] to temp\nIncrement left by 1\nElse:\nAppend a[right] to temp\nIncrement right by 1\n\nWhile left <= mid:\nAppend a[left] to temp\nIncrement left by 1\n\nWhile right <= high:\nAppend a[right] to temp\nIncrement right by 1\n\nCopy elements from temp back to array a\n\nFunction mergeSort(a, low, high):\nIf low equals high, return\nCalculate mid as (low + high) / 2\nRecursively call mergeSort with arguments (a, low, mid)\nRecursively call mergeSort with arguments (a, mid + 1, high)\nCall merge with arguments (a, low, mid, high)\n\nFunction team(a, n):\nCall mergeSort with arguments (a, 0, n - 1)\nReturn cnt"
  },
  {
    "sign_no": 40,
    "question": "Given an array ‘Arr’ that has ‘N’ elements. You have to find the subarray of ‘Arr’ that has the largest product. You must return the product of the subarray with the maximum product.",
    "name": "Maximum Product Subarray",
    "topic": "array",
    "level": "easy",
    "url": "https://leetcode.com/problems/maximum-product-subarray/",
    "approach": "the intuition to the problem is observation based\nas we know we have to find max product that means we do not have to include 0 in subarray, and we try to take even number of negative to make the whole product max.\nso we can have two var storing the prefix and suffix product. if any of them become 0 we make them 1 .\nthen we can compare and update our maxi to the max of maxi and both pref and suff at that position.",
    "pseudo_code": "FUNCTION maxProduct(nums):\npref = 1\nsuff = 1\nmaxi = INT_MIN\nn = length of nums\n\nFOR i = 0 to n - 1:\nIF pref is 0:\npref = 1\nIF suff is 0:\nsuff = 1\n\npref = pref * nums[i]\nsuff = suff * nums[n - i - 1]\nmaxi = max(maxi, max(pref, suff))\n\nRETURN maxi"
  },
  {
    "sign_no": 41,
    "question": "You are given an integer array 'A' of size 'N', sorted in non-decreasing order. You are also given an integer 'target'.\n\n\nYour task is to write a function to search for 'target' in the array 'A'. If it exists, return its index in 0-based indexing. If 'target' is not present in the array 'A', return -1.\n\n\nNote:\n\nYou must write an algorithm whose time complexity is O(LogN)",
    "name": "Binary Search to find X in sorted array",
    "topic": "bs",
    "level": "easy",
    "url": "https://leetcode.com/problems/binary-search/",
    "approach": "use binary search...let low and high at 0, n-1 and loop while low <= high\ntake mid ..as (low + high) / 2...and if mid == target then its out answer else if \na[mid] > target that means our target is in left half so high = mid - 1;\nelse our target is in right half so low = mid + 1;",
    "pseudo_code": "int search(vector<int> &nums, int target) {\nint low = 0, high = nums.size() - 1;\nint mid;\n\nwhile (low <= high) {\nmid = (low + high) / 2; // Calculate the middle index\n\nif (nums[mid] == target) {\nreturn mid; // If the target is found at mid, return mid\n} else if (nums[mid] > target) {\nhigh = mid - 1; // If the target is less than nums[mid], search the left half\n} else {\nlow = mid + 1; // If the target is greater than nums[mid], search the right half\n}\n}\n\nreturn -1; // If the target is not found, return -1\n}"
  },
  {
    "sign_no": 42,
    "question": "You are given an array 'arr' sorted in non-decreasing order and a number 'x'.\n\n\nYou must return the index of lower bound of 'x'.\n\n\nNote:\n\nFor a sorted array 'arr', 'lower_bound' of a number 'x' is defined as the smallest index 'idx' such that the value 'arr[idx]' is not less than 'x'\n\nIf all numbers are smaller than 'x', then 'n' should be the 'lower_bound' of 'x', where 'n' is the size of array.\n\nConsider 0-based indexing.",
    "name": "Implement Lower Bound",
    "topic": "bs",
    "level": "easy",
    "url": "https://bit.ly/3Cf398N",
    "approach": "we have n lenght of arr, x and arr\nlower bound of x is element that is nearest greater or equal to x;\nand if all elements are small then n will be our answer..as we have to return the index of lowerbound\nso let low and high then loop while low <= high..take mid\nif arr[mid] >= x then it can be our possible answer so we update the answer variable to ans = mid;\nand eliminate the right half..as high = mid -1;\nelse low = mid +1;\nat the end ans will be our lower bound index.",
    "pseudo_code": ""
  },
  {
    "sign_no": 43,
    "question": "You are given a sorted array ‘arr’ containing ‘n’ integers and an integer ‘x’.\n\n\nImplement the ‘upperBound’ function to find the index of the upper bound of 'x' in the array.\n\n\nNote:\n\nThe upper bound in a sorted array is the index of the first value that is greater than a given value. \nIf the greater value does not exist then the answer is 'n', Where 'n' is the size of the array.\nWe are using 0-based indexing.\nTry to write a solution that runs in log(n) time complexity.",
    "name": "Implement Upper Bound",
    "topic": "bs",
    "level": "easy",
    "url": "https://bit.ly/3CgDDjE",
    "approach": "the upper bound is the index that is nearest greater then given target.\nso lets take ans = n; and low , high\nloop ..take mid..and if mid > x then it can be our possible ans..so update ans = mid\nand eliminate the right half as high = mid - 1;\nelse eliminate the left half.",
    "pseudo_code": ""
  },
  {
    "sign_no": 44,
    "question": "You are given a sorted array 'arr' of distinct values and a target value 'm'.\n\n\nYou need to search for the index of the target value in the array.\n\n\nNote:\n\nIf the value is present in the array, return its index.\nIf the value is absent, determine the index where it would be inserted in the array while maintaining the sorted order. ",
    "name": "Search Insert Position",
    "topic": "bs",
    "level": "easy",
    "url": "https://leetcode.com/problems/search-insert-position/#:~:text=Search%20Insert%20Position%20%2D%20LeetCode&text=Given%20a%20sorted%20array%20of,(log%20n)%20runtime%20complexity.",
    "approach": "lower bound of the index will be out insert position.\nas we the target is present then it will get return..else the newrest greater ..(lower bound)",
    "pseudo_code": ""
  },
  {
    "sign_no": 45,
    "question": "You're given a sorted array 'a' of 'n' integers and an integer 'x'.\n\n\nFind the floor and ceiling of 'x' in 'a[0..n-1]'.\n\n\nNote:\n\nFloor of 'x' is the largest element in the array which is smaller than or equal to 'x'.\nCeiling of 'x' is the smallest element in the array greater than or equal to 'x'.",
    "name": "Floor/Ceil in Sorted Array",
    "topic": "bs",
    "level": "medium",
    "url": "https://www.codingninjas.com/codestudio/problems/ceiling-in-a-sorted-array_1825401",
    "approach": "taking lower and upper bound into consideration..\nif the element is present in the array then it will be both ceil and floor..\nif not then the lowerbound will be the ceil..and the left of lowerbound will be the floor...\n\nif arr[mid] == tar..return {mid, mid};\nif > tar then it can be our possible ceil so ceil = mid and high = mid - 1;\nif < tar then it can be our possible floor so floor = mid and low = mid + 1;",
    "pseudo_code": "Function getFloorAndCeil(arr: Array of integers, n: Integer, x: Integer) -> Pair of Integers:\nInitialize low = 0, high = n - 1\nInitialize ans as a pair of integers with default values (-1, -1)\n\nWhile low <= high:\nmid = (low + high) / 2\n\nIf arr[mid] == x:\nSet ans as a pair containing x as both floor and ceiling value\nReturn ans\nElse If arr[mid] > x:\nUpdate ans.second to arr[mid] (potential ceiling value)\nUpdate high to mid - 1 (move to the left half)\nElse:\nUpdate ans.first to arr[mid] (potential floor value)\nUpdate low to mid + 1 (move to the right half)\n\nReturn ans containing the floor and ceiling values of x"
  },
  {
    "sign_no": 46,
    "question": "You have been given a sorted array/list 'arr' consisting of ‘n’ elements. You are also given an integer ‘k’.\n\n\nNow, your task is to find the first and last occurrence of ‘k’ in 'arr'.\n\n\nNote :\n\n1. If ‘k’ is not present in the array, then the first and the last occurrence will be -1. \n2. 'arr' may contain duplicate elements.",
    "name": "Find the first or last occurrence of a given number in a sorted array",
    "topic": "bs",
    "level": "easy",
    "url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/",
    "approach": "if the element is present then lower bound will be first occurences and the upperbound - 1 will be the last occurence\nso we take two loops..first for lower bound and one for upper bound..\n\n1st loop to find out the 1st occurence..if mid == target then it can be our ans and then eliminate the right half so we get to left and find out lower index of target for first occur.\nsimilerly we move to right and eliminate left for last occur...\n\nsee the pseudo code for better clarity.",
    "pseudo_code": "Function firstAndLastPosition(arr: Array of integers, n: Integer, k: Integer) -> Pair of Integers:\nInitialize low = 0, high = n - 1\nInitialize ans as a pair of integers with default values (-1, -1)\n\n// Finding the first occurrence of k\nWhile low <= high:\nmid = (low + high) / 2\n\nIf arr[mid] == k:\nSet ans.first = mid (potential first occurrence)\nUpdate high to mid - 1 (move to the left half)\nElse If arr[mid] > k:\nUpdate high to mid - 1 (move to the left half)\nElse:\nUpdate low to mid + 1 (move to the right half)\n\n// If k is not found, return {-1, -1}\nIf ans.first == -1:\nReturn {-1, -1}\n\n// Reset low and high for the second binary search\nlow = 0, high = n - 1\n\n// Finding the last occurrence of k\nWhile low <= high:\nmid = (low + high) / 2\n\nIf arr[mid] == k:\nSet ans.second = mid (potential last occurrence)\nUpdate low to mid + 1 (move to the right half)\nElse If arr[mid] > k:\nUpdate high to mid - 1 (move to the left half)\nElse:\nUpdate low to mid + 1 (move to the right half)\n\nReturn ans containing the first and last occurrences of k"
  },
  {
    "sign_no": 47,
    "question": "You have been given a sorted array/list of integers 'arr' of size 'n' and an integer 'x'.\n\n\nFind the total number of occurrences of 'x' in the array/list.",
    "name": "Count occurrences of a number in a sorted array with duplicates",
    "topic": "bs",
    "level": "easy",
    "url": "https://bit.ly/3SVcOqW",
    "approach": "find first occurence last occurence index and find out the number of elements..(see last question for first and last occurences)",
    "pseudo_code": ""
  },
  {
    "sign_no": 48,
    "question": "You have been given a sorted array/list 'arr' consisting of ‘n’ elements. You are also given an integer ‘k’.\n\n\nNow the array is rotated at some pivot point unknown to you.\n\n\nFor example, if 'arr' = [ 1, 3, 5, 7, 8], then after rotating 'arr' at index 3, the array will be 'arr' = [7, 8, 1, 3, 5].\n\n\nNow, your task is to find the index at which ‘k’ is present in 'arr'.",
    "name": "Search in Rotated Sorted Array I",
    "topic": "bs",
    "level": "medium",
    "url": "https://leetcode.com/problems/search-in-rotated-sorted-array/",
    "approach": "as the array is rotated some times to the right that means the array is not fully sorted but we know that there must be a part that will be sorted at a time..lets say left or right may be sorted..\nfor ex...1 3 5 7 8 rotated to 7 8 1 3 5 then take a mid..it will be at index 2..\nthen we can check if a[low] < a[mid] that means the left half is sorted...else the right half will be sorted.\nafter finding the sorted half we can compare the mid and low with k so we can be sure that K lies in that range..\nlet say if a[low] <= k && a[mid] >= k then we can go with this half as high = mid-1..if not then it means k is not in this half so we can put low to mid + 1;\nsimilerly for right part...we compare the k with mid and high if its present in that part then low = mid + 1...else high = mid - 1;",
    "pseudo_code": "Function search(arr: Array of integers, n: Integer, k: Integer) -> Integer:\nInitialize low = 0, high = n - 1\n\nWhile low <= high:\nmid = (low + high) / 2\n\nIf arr[mid] == k:\nReturn mid (index of the target element)\n\n// Check if the left half is sorted\nIf arr[low] <= arr[mid]:\nIf arr[low] <= k and arr[mid] >= k:\nUpdate high to mid - 1 (move to the left half)\nElse:\nUpdate low to mid + 1 (move to the right half)\n// If the left half is not sorted, then the right half must be sorted\nElse:\nIf arr[mid] <= k and arr[high] >= k:\nUpdate low to mid + 1 (move to the right half)\nElse:\nUpdate high to mid - 1 (move to the left half)\n\nReturn -1 (target element not found in the array)"
  },
  {
    "sign_no": 49,
    "question": "You are given a rotated sorted array 'a' of length 'n' and a 'key'. You need to determine if the 'key' exists in the array 'a'.\n\n\nThe given sorted array is rotated from an unknown index 'x'. Such that after rotation the array became [a[x], a[x+1]...., a[n-1], a[1]..., a[x-1]], (0-based indexing). For example, if the array is [1, 2, 3, 4, 5] and x = 2 then the rotated array will be [3, 4, 5, 1, 2, 3].\n\n\nReturn True if the 'key' is found in 'a'. Otherwise, return False.\n\n\nNote: Array ‘a’ may contain duplicate elements.",
    "name": "Search in Rotated Sorted Array II",
    "topic": "bs",
    "level": "medium",
    "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/",
    "approach": "similer to previous question\n\ntake care of duplicates",
    "pseudo_code": ""
  },
  {
    "sign_no": 50,
    "question": "You are given an array 'arr' of size 'n' having unique elements that has been sorted in ascending order and rotated between 1 and 'n' times which is unknown.\n\n\nThe rotation involves shifting every element to the right, with the last element moving to the first position. For example, if 'arr' = [1, 2, 3, 4] was rotated one time, it would become [4, 1, 2, 3].\n\n\nYour task is to find the minimum number in this array.",
    "name": "Find minimum in Rotated Sorted Array",
    "topic": "bs",
    "level": "medium",
    "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/",
    "approach": "to find out the min in rotated array ...\nlet low and high then loop and take mid\nif a[low] <= a[high] that means we got in the sorted part of the whole array so our ans can be the prev ansewrs or the a[low] whichever is the min.\nif a[low] <= a[mid] then ans = min of ans, a[low] then low = mid + 1;\nelse ans = min of ans, a[mid] then high = mid - 1;\n\nif left part is sorted then we take the min of that part and move to the right part...and if right part is sorted then the mid will be min so we update the ans accordingly.",
    "pseudo_code": "Function findMin(arr: Array of integers) -> Integer:\nInitialize n as the size of arr\nInitialize low = 0, high = n - 1\nInitialize ans = +∞ (positive infinity)\n\nWhile low <= high:\nmid = (low + high) / 2\n\n// Check if the current subarray is sorted\nIf arr[low] <= arr[high]:\nUpdate ans to be the minimum between ans and arr[low]\nBreak the loop (the minimum element is found in the sorted subarray)\n\n// If the left half is sorted\nIf arr[low] <= arr[mid]:\nUpdate ans to be the minimum between ans and arr[low]\nUpdate low to mid + 1 (move to the right half)\n// If the left half is not sorted, then the right half must be sorted\nElse:\nUpdate ans to be the minimum between ans and arr[mid]\nUpdate high to mid - 1 (move to the left half)\n\nReturn ans (the minimum element in the array)"
  },
  {
    "sign_no": 51,
    "question": "You are given an array 'arr' having 'n' distinct integers sorted in ascending order. The array is right rotated 'r' times\n\n\nFind the minimum value of 'r'.\n\n\nRight rotating an array means shifting the element at 'ith' index to (‘i+1') mod 'n' index, for all 'i' from 0 to ‘n-1'.",
    "name": "Find out how many times has an array been rotated",
    "topic": "bs",
    "level": "easy",
    "url": "https://bit.ly/3dEvWJD",
    "approach": "to find the number of rotation then we have to find out the index of min element\nthe index will be our number of rotations...\nfor ex -> 2,3,1 is rotated r times so to find our the rotations we find the index of min element...here its at index 2\nso the number of rotation is 2 such that the min element that should be at index zero has come to index 2",
    "pseudo_code": "Function findKRotation(arr: Array of integers) -> Integer:\nInitialize n as the size of arr\nInitialize low = 0, high = n - 1, and minIdx = n - 1 (assuming no rotation)\n\nWhile low <= high:\nmid = (low + high) / 2\n\n// Check if the current subarray is sorted\nIf arr[low] <= arr[high]:\n// Check if the minimum element is in the left half\nIf arr[minIdx] > arr[low]:\nUpdate minIdx to low\nBreak the loop (the minimum element is found in the sorted subarray)\n\n// If the left half is sorted\nIf arr[low] <= arr[mid]:\n// Check if the minimum element is in the left half\nIf arr[minIdx] > arr[low]:\nUpdate minIdx to low\nUpdate low to mid + 1 (move to the right half)\n// If the left half is not sorted, then the right half must be sorted\nElse:\n// Check if the minimum element is in the right half\nIf arr[minIdx] > arr[mid]:\nUpdate minIdx to mid\nUpdate high to mid - 1 (move to the left half)\n\nReturn minIdx (the index of the minimum element, indicating the number of rotations)"
  },
  {
    "sign_no": 52,
    "question": "You are given a sorted array ‘arr’ of ‘n’ numbers such that every number occurred twice in the array except one, which appears only once.\n\n\nReturn the number that appears once.",
    "name": "Single element in a Sorted Array",
    "topic": "bs",
    "level": "easy",
    "url": "https://leetcode.com/problems/single-element-in-a-sorted-array/",
    "approach": "given the sorted array and to find the single element \nthere are some edge cases...n == 1, or at index 0 and index n- 1 we have to check explicitly.\non orher casees we have an intuation that all numbers apper 2 times except one that means the left part from that number and the right part differs...in left part the same element occur at even, odd (index) place while in right part the same element occur at odd, even (index) part...that means we can eliminate one of the half to reach our ansewer.\nif mid is odd then mid-1 should be equal or if midd is even then mid+1 should be equal that means the single element is not in this half so we move to right one..as low = mid + 1;\nelse we move to the left one as high = mid - 1;\nwe wil check if mid is not equal to mid - 1 and mid - 2 if both are true that means its our single element.",
    "pseudo_code": "Function singleNonDuplicate(arr: Array of integers) -> Integer:\nInitialize n as the size of arr\n\n// Base cases\nIf n is 1, return the only element in arr\n\n// Check the first and last elements\nIf arr[0] is not equal to arr[1], return arr[0]\nIf arr[n-1] is not equal to arr[n-2], return arr[n-1]\n\nInitialize low = 1 and high = n - 2 (excluding the first and last elements)\n\n// Binary search\nWhile low <= high:\nmid = (low + high) / 2\n\n// If the middle element is the single non-duplicate\nIf arr[mid] is not equal to arr[mid-1] and arr[mid] is not equal to arr[mid+1], return arr[mid]\n\n// If the single non-duplicate is in the right half and mid is odd, or in the left half and mid is even\nIf (mid is odd and arr[mid] is equal to arr[mid-1]) or (mid is even and arr[mid] is equal to arr[mid+1]):\nUpdate low to mid + 1 (move to the right half)\nElse:\nUpdate high to mid - 1 (move to the left half)\n\nReturn -1 (if no single non-duplicate is found)"
  },
  {
    "sign_no": 53,
    "question": "You are given an array 'arr' of length 'n'. Find the index(0-based) of a peak element in the array. If there are multiple peak numbers, return the index of any peak number.\n\n\nPeak element is defined as that element that is greater than both of its neighbors. If 'arr[i]' is the peak element, 'arr[i - 1]' < 'arr[i]' and 'arr[i + 1]' < 'arr[i]'.\n\n\nAssume 'arr[-1]' and 'arr[n]' as negative infinity.\n\n\nNote:\n\n1. There are no 2 adjacent elements having same value (as mentioned in the constraints).\n2. Do not print anything, just return the index of the peak element (0 - indexed).\n3. 'True'/'False' will be printed depending on whether your answer is correct or not.",
    "name": "Find peak element",
    "topic": "bs",
    "level": "hard",
    "url": "https://leetcode.com/problems/find-peak-element/#:~:text=Find%20Peak%20Element%20%2D%20LeetCode&text=A%20peak%20element%20is%20an,to%20any%20of%20the%20peaks.",
    "approach": "to find the peak element we check the mid with mid-1 and mid + 1\nif mid is > then both then its our peak element\nhowever we have to take care of n == 1, index 0 and n-1 explicitly.\nto eliminate a half we have to find the slope...finding out wheater we are going upwards or downwards...\nand to find this out we check our mid with mid-1 and if mid > mid-1 then it means we are going upwards from left so we eliminate the left half ..as ...low = mid + 1;\nelse we eliminate the right half as high = mid - 1;",
    "pseudo_code": "Function findPeakElement(arr: Array of integers) -> Integer:\nInitialize n as the size of arr\n\n// Edge cases:\nIf n is 1, return 0 (index of the single element).\nIf the first element is greater than the second element, return 0 (index of the first element).\nIf the last element is greater than the second last element, return n - 1 (index of the last element).\n\nInitialize low = 1 and high = n - 2 (excluding the first and last elements).\n\n// Binary search\nWhile low <= high:\nmid = (low + high) / 2\n\n// If arr[mid] is the peak (greater than its neighbors)\nIf arr[mid - 1] < arr[mid] and arr[mid] > arr[mid + 1], return mid\n\n// If we are in the left half and arr[mid] is increasing\nIf arr[mid] > arr[mid - 1], update low to mid + 1 (move to the right half)\n\n// If we are in the right half or arr[mid] is decreasing\n// Or, arr[mid] is a common point (equal to its neighbors)\nElse update high to mid - 1 (move to the left half)\n\nReturn -1 (if no peak element is found, which should not happen in a valid input)"
  },
  {
    "sign_no": 54,
    "question": "You are given a positive integer ‘n’.\n\n\nYour task is to find and return its square root. If ‘n’ is not a perfect square, then return the floor value of sqrt(n).",
    "name": "Find square root of a number in log n",
    "topic": "bs",
    "level": "medium",
    "url": "https://bit.ly/3JXtGcE",
    "approach": "use BS on answers..let low = 1 and high = n\nlet mid and temp = mid*mid;\ncheck if n > temp that means right half can't be answer so we eliminate it as high = mid -1;\nelse low = mid + 1;\nhigh will we our answer as it only changes when temp > n but low will change and move forward until low > high and break out of loop",
    "pseudo_code": "Function floorSqrt(n: integer) -> integer:\nInitialize low as 1 and high as n\n\n// Binary search\nWhile low <= high:\nmid = (low + high) / 2\ntemp = mid * mid\n\n// If mid * mid is less than or equal to n,\n// move to the right half\nIf temp <= n, update low to mid + 1\n\n// If mid * mid is greater than n,\n// move to the left half\nElse, update high to mid - 1\n\nReturn high (since high will be the largest integer\nwhose square is less than or equal to n)"
  },
  {
    "sign_no": 55,
    "question": "You are given two positive integers 'n' and 'm'. You have to return the 'nth' root of 'm', i.e. 'm(1/n)'. If the 'nth root is not an integer, return -1.\n\n\nNote:\n\n'nth' root of an integer 'm' is a number, which, when raised to the power 'n', gives 'm' as a result.",
    "name": "Find the Nth root of a number using binary search",
    "topic": "bs",
    "level": "medium",
    "url": "https://bit.ly/3zWNyrL",
    "approach": "similer to previous question with some new case as we have to find the nth root of m\nlet low=1, high = m...loop ..take mid..then \nwe have to find out if the current mid can be our anser or greater or lesser so we ahve a finctino that takes m, n, mid \nans = 1..loop n times ans = ans * midl\nif in any iteration ans becomes > m that means we have to eliminate the right half so we return 2..if ans == m then its our ans..if ans < m then we have to return to right and eliminate the left half as our ans is small so we return 0\nfrom above ..if val is 1 then its our ans..if 2 then high = mid -1, if 0 then low = mid + 1;\n\nat then end we can say that we have not find the ans and can return -1;",
    "pseudo_code": "Function func(n: integer, m: integer, mid: integer) -> integer:\nInitialize ans as 1\nIterate i from 1 to n:\nans = ans * mid\nIf ans > m, return 2 (indicating that mid is too large)\n\nIf ans equals m, return 1 (indicating that mid is the nth root of m)\nOtherwise, return 0 (indicating that mid is too small)\n\nFunction NthRoot(n: integer, m: integer) -> integer:\nInitialize low as 1 and high as m\n\n// Binary search\nWhile low <= high:\nmid = (low + high) / 2\nval = func(n, m, mid)\n\nIf val equals 1, return mid\nIf val equals 2, update high to mid - 1\nIf val equals 0, update low to mid + 1\n\nReturn -1 (indicating that no nth root exists within the given range)"
  },
  {
    "sign_no": 56,
    "question": "A monkey is given ‘n’ piles of bananas, where the 'ith' pile has ‘a[i]’ bananas. An integer ‘h’ is also given, which denotes the time (in hours) in which all the bananas should be eaten.\n\n\nEach hour, the monkey chooses a non-empty pile of bananas and eats ‘m’ bananas. If the pile contains less than ‘m’ bananas, then the monkey consumes all the bananas and won’t eat any more bananas in that hour.\n\n\nFind the minimum number of bananas ‘m’ to eat per hour so that the monkey can eat all the bananas within ‘h’ hours.",
    "name": "Koko Eating Bananas",
    "topic": "bs",
    "level": "hard",
    "url": "https://leetcode.com/problems/koko-eating-bananas/",
    "approach": "we can't directly use BS but we can see that the min rate will 1 and the max rate at which koko can eat is max(array)\nso we can apply BS on answer ..low = 1, high = max(arr);\nloop and take mid ...for each mid we have to calculate the number of hours it will take to eat all bananas..\nso we make a function and linearly iterate through array and add the hours required for that pile to our total hour\nfor that pile will be ciel of arr[i] / mid \n\nto eliminate the half we compare the totalH to given h..if totalH <= given H that means our rate can be higher so we eliminate the right half as high = mid - 1...else low = mid + 1;\nat the end the low will be our answer because there will be point when low = high and that point the high will move to mid - 1..but low remain at place will be our anser.",
    "pseudo_code": "Function findMax(v: vector<int>) -> int:\nInitialize maxi as INT_MIN\nFor each element i in vector v:\nmaxi = max(maxi, v[i])\nReturn maxi\n\nFunction calculateTotalHours(v: vector<int>, hourly: int) -> long long:\nInitialize totalH as 0\nFor each element i in vector v:\ntotalH += ceil((double)v[i] / hourly)\nReturn totalH\n\nFunction minimumRateToEatBananas(v: vector<int>, h: int) -> int:\nInitialize low as 1\nInitialize high using findMax(v)\n\n// Binary search\nWhile low <= high:\nmid = (low + high) / 2\ntotalH = calculateTotalHours(v, mid)\nIf totalH <= h:\nhigh = mid - 1\nElse:\nlow = mid + 1\n\nReturn low"
  },
  {
    "sign_no": 57,
    "question": "You are given 'n' roses and you are also given an array 'arr' where 'arr[i]' denotes that the 'ith' rose will bloom on the 'arr[i]th' day.\n\n\nYou can only pick already bloomed roses that are adjacent to make a bouquet. You are also told that you require exactly 'k' adjacent bloomed roses to make a single bouquet.\n\n\nFind the minimum number of days required to make at least 'm' bouquets each containing 'k' roses. Return -1 if it is not possible.",
    "name": "Minimum days to make M bouquets",
    "topic": "bs",
    "level": "hard",
    "url": "https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/",
    "approach": "similer to prev question..\nwe use BS on ans as low will be the min of arr and high will be max\nloop and take mid..now for each mid we have to find out if it is possible to have m booke with k flowers on mid th day or not\nif possible then eliminate the right half\nif not then eliminate the left half\nat the end low will be our ans.",
    "pseudo_code": "Function isPossible(arr: vector<int>, day: int, m: int, k: int, size: int) -> bool:\nInitialize cnt and ans as 0\nFor i = 0 to size-1:\nIf arr[i] <= day:\nIncrement cnt\nElse:\nIncrement ans by cnt / k\nReset cnt to 0\nIncrement ans by cnt / k\nIf ans >= m:\nReturn true\nElse:\nReturn false\n\nFunction findMin(arr: vector<int>, size: int) -> int:\nInitialize minn as INT_MAX\nFor i = 0 to size-1:\nUpdate minn as min(minn, arr[i])\nReturn minn\n\nFunction findMax(arr: vector<int>, size: int) -> int:\nInitialize maxi as INT_MIN\nFor i = 0 to size-1:\nUpdate maxi as max(maxi, arr[i])\nReturn maxi\n\nFunction roseGarden(arr: vector<int>, k: int, m: int) -> int:\nInitialize size as the size of arr\nInitialize low as findMin(arr, size)\nInitialize high as findMax(arr, size)\n\nIf m * k > size:\nReturn -1\n\nWhile low <= high:\nInitialize mid as (low + high) / 2\nIf isPossible(arr, mid, m, k, size):\nUpdate high as mid - 1\nElse:\nUpdate low as mid + 1\n\nReturn low"
  },
  {
    "sign_no": 58,
    "question": "You are given an array of integers 'arr' and an integer 'limit'.\n\n\nYour task is to find the smallest positive integer divisor, such that upon dividing all the elements of the given array by it, the sum of the division's result is less than or equal to the given integer's limit.\n\n\nNote:\n\nEach result of the division is rounded to the nearest integer greater than or equal to that element. For Example, 7/3 = 3.",
    "name": "Find the smallest Divisor",
    "topic": "bs",
    "level": "easy",
    "url": "https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/",
    "approach": "similer to prev question...\nlow will be 1 and high will be max(arr) as we have to divide so we can't take low = 0 and the min sum we can get is 1\nfor each mid we have to check if the its in limit or not...we can do that using a loop in another function ..\nif its in limit then we can eliminate the right half ..high = mid - 1;\nelse low = mid + 1;\n\nfinally low will be our ans.",
    "pseudo_code": "Function isInLimit(arr: vector<int>, limit: int, num: int) -> bool:\nInitialize sum as 0\nFor each element in arr:\nAdd the ceiling of the element divided by num to sum\nIf sum exceeds limit:\nReturn false\nReturn true\n\nFunction findMax(arr: vector<int>) -> int:\nInitialize maxi as INT_MIN\nFor each element in arr:\nUpdate maxi as the maximum of maxi and the current element\nReturn maxi\n\nFunction smallestDivisor(arr: vector<int>, limit: int) -> int:\nInitialize low as 1\nInitialize high as findMax(arr)\n\nWhile low <= high:\nInitialize mid as the average of low and high\nIf isInLimit(arr, limit, mid):\nUpdate high as mid - 1\nElse:\nUpdate low as mid + 1\n\nReturn low"
  },
  {
    "sign_no": 59,
    "question": "You are the owner of a Shipment company. You use conveyor belts to ship packages from one port to another. The packages must be shipped within 'd' days.\n\n\nThe weights of the packages are given in an array 'weights'. The packages are loaded on the conveyor belts every day in the same order as they appear in the array. The loaded weights must not exceed the maximum weight capacity of the ship.\n\n\nFind out the least-weight capacity so that you can ship all the packages within 'd' days.",
    "name": "Capacity to Ship Packages within D Days",
    "topic": "bs",
    "level": "hard",
    "url": "https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/",
    "approach": "similer to prev...\nuse bs on ans...as low will be the max of arr and high will be the sum of arr...\n\nfor each mid we have to check how may days it takes with that capacity..\nif the counted days < = given days then we eliminate the right half \nelse eliminate the left half",
    "pseudo_code": "Function findSum(arr: vector<int>) -> int:\nInitialize sum as 0\nFor each element in arr:\nAdd the element to sum\nReturn sum\n\nFunction findMax(arr: vector<int>) -> int:\nInitialize maxi as INT_MIN\nFor each element in arr:\nUpdate maxi as the maximum of maxi and the current element\nReturn maxi\n\nFunction noOfDays(arr: vector<int>, weight: int) -> int:\nInitialize n as the size of arr\nInitialize sum as 0\nInitialize days as 1\n\nFor i from 0 to n-1:\nIf sum + arr[i] > weight:\nIncrement days by 1\nSet sum to arr[i]\nElse:\nAdd arr[i] to sum\n\nReturn days\n\nFunction leastWeightCapacity(arr: vector<int>, d: int) -> int:\nInitialize n as the size of arr\nInitialize low as findMax(arr)\nInitialize high as findSum(arr)\n\nWhile low <= high:\nInitialize mid as the average of low and high\nInitialize temp as the result of noOfDays(arr, mid)\n\nIf temp <= d:\nUpdate high as mid - 1\nElse:\nUpdate low as mid + 1\n\nReturn low"
  },
  {
    "sign_no": 60,
    "question": "You are given a strictly increasing array 'vec' and a positive integer 'k'.\n\n\nFind the 'kth' positive integer missing from 'vec'.",
    "name": "Kth Missing Positive Number",
    "topic": "bs",
    "level": "easy",
    "url": "https://leetcode.com/problems/kth-missing-positive-number/#:~:text=Given%20an%20array%20arr%20of,13%2C...%5D.",
    "approach": "we have sorted array so we can find out the number of missing number upto that index...\nheres how -> a[i] - i - 1;\nif a[i]-i-1 < k then we eliminate the left half as the missgine number is lesser then required..\nelse high = mid - 1;\n\nour final anser will be high + k + 1; high is the index that has excatly k elements missing...and k is the number of that missing element \nfor ex -> 2,4,5,7 and k = 3\nhigh will be at index 2 then our ans will be high + k + 1..from 1 2 3 4 5 6 7---> 6 is at index 5 = k + high and + 1 = 6 the number that is kth missing.",
    "pseudo_code": "Function missingK(vec: vector<int>, n: int, k: int) -> int:\nInitialize low as 0\nInitialize high as n - 1\n\nWhile low <= high:\nInitialize mid as the average of low and high\nCalculate the number of missing elements before mid: vec[mid] - mid - 1\n\nIf the number of missing elements before mid is less than k:\nUpdate low as mid + 1\nElse:\nUpdate high as mid - 1\n\nReturn k + high + 1"
  },
  {
    "sign_no": 61,
    "question": "You are given an array 'arr' consisting of 'n' integers which denote the position of a stall.\n\n\nYou are also given an integer 'k' which denotes the number of aggressive cows.\n\n\nYou are given the task of assigning stalls to 'k' cows such that the minimum distance between any two of them is the maximum possible.\n\n\nPrint the maximum possible minimum distance.",
    "name": "Aggressive Cows",
    "topic": "bs",
    "level": "hard",
    "url": "https://www.spoj.com/problems/AGGRCOW/",
    "approach": "given array is not sorted so we sort the array first..\nlet low = 0, and high = distance between a[0] and a[n-1]\n\nfor each mid we have to check if we can place the cows at minimum mid distance or not\nif we can place then eliminate the left half as we want to search for maximum of minimum possible distance\nif we can not place then eliminate the right half...\nat the end high will be our ans;",
    "pseudo_code": "Function canBePlaced(arr: vector<int>, dist: int, cows: int) -> bool:\nInitialize placedCows as 1\nInitialize prev as arr[0]\n\nFor i from 1 to n - 1:\nIf arr[i] - prev >= dist:\nIncrement placedCows by 1\nUpdate prev as arr[i]\n\nIf placedCows equals cows:\nReturn true\n\nReturn false\n\nFunction aggressiveCows(arr: vector<int>, k: int) -> int:\nSort arr in non-decreasing order\nInitialize low as 0\nInitialize high as arr[n - 1] - arr[0]\n\nWhile low <= high:\nInitialize mid as the average of low and high\n\nIf canBePlaced(arr, mid, k):\nUpdate low as mid + 1\nElse:\nUpdate high as mid - 1\n\nReturn high"
  },
  {
    "sign_no": 62,
    "question": "Given an array ‘arr’ of integer numbers, ‘arr[i]’ represents the number of pages in the ‘i-th’ book.\n\n\nThere are ‘m’ number of students, and the task is to allocate all the books to the students.\n\n\nAllocate books in such a way that:\n\n1. Each student gets at least one book.\n2. Each book should be allocated to only one student.\n3. Book allocation should be in a contiguous manner.\n\n\nYou have to allocate the book to ‘m’ students such that the maximum number of pages assigned to a student is minimum.\n\n\nIf the allocation of books is not possible, return -1.",
    "name": "Book Allocation Problem",
    "topic": "bs",
    "level": "hard",
    "url": "https://bit.ly/3MZQOct",
    "approach": "similer to prev question here we take low as max of arr and high as sum of arr\n\nfor each mid we have to find out how many students needed for each mid such that our mid is minimum and number of students is equal to m...\nif nos > m then we need to give more pages per student so we increase the mid and to do that we eliminate the left half\nelse we eliminate the riight half...\n\nat the end low will be our ans ",
    "pseudo_code": "Function noOfStudents(arr: vector<int>, n: int, maxPages: int) -> int:\nInitialize nos as 1\nInitialize pages as 0\n\nFor i from 0 to n - 1:\nIf pages + arr[i] <= maxPages:\nIncrement pages by arr[i]\nElse:\nIncrement nos by 1\nSet pages to arr[i]\n\nReturn nos\n\nFunction findPages(arr: vector<int>, n: int, m: int) -> int:\nIf m > n:\nReturn -1\n\nInitialize low as the maximum element in arr\nInitialize high as the sum of all elements in arr\n\nWhile low <= high:\nInitialize mid as the average of low and high\n\nIf noOfStudents(arr, n, mid) > m:\nUpdate low as mid + 1\nElse:\nUpdate high as mid - 1\n\nReturn low"
  },
  {
    "sign_no": 63,
    "question": "Given an integer array ‘A’ of size ‘N’ and an integer ‘K'.\n\n\nSplit the array ‘A’ into ‘K’ non-empty subarrays such that the largest sum of any subarray is minimized.\n\n\nYour task is to return the minimized largest sum of the split.\n\n\nA subarray is a contiguous part of the array.",
    "name": "Split array - Largest Sum",
    "topic": "bs",
    "level": "hard",
    "url": "https://leetcode.com/problems/split-array-largest-sum/",
    "approach": "similer to prevs.....the min sum can be the max of arr and max sum can be sum of arr\nso low = max of arr and high = sum of arr\nfor each mid we have to find out the number of parts we can do of array with max sum as mid\nif number of parts > k then we have to increase the mid hence eliminate left half\nelse eliminate right half\nthe low will be our ans at the end....",
    "pseudo_code": "Function findParts(a: vector<int>, maxSum: int) -> int:\nInitialize n as the size of vector a\nInitialize sum as 0\nInitialize part as 1\n\nFor i from 0 to n - 1:\nIf sum + a[i] <= maxSum:\nIncrement sum by a[i]\nElse:\nIncrement part by 1\nSet sum to a[i]\n\nReturn part\n\nFunction largestSubarraySumMinimized(a: vector<int>, k: int) -> int:\nInitialize n as the size of vector a\nIf k > n:\nReturn -1\n\nInitialize low as the maximum element in vector a\nInitialize high as the sum of all elements in vector a\n\nWhile low <= high:\nInitialize mid as the average of low and high\n\nIf findParts(a, mid) > k:\nUpdate low as mid + 1\nElse:\nUpdate high as mid - 1\n\nReturn low"
  },
  {
    "sign_no": 64,
    "question": "Given an array/list of length ‘n’, where the array/list represents the boards and each element of the given array/list represents the length of each board. Some ‘k’ numbers of painters are available to paint these boards. Consider that each unit of a board takes 1 unit of time to paint.\n\n\nYou are supposed to return the area of the minimum time to get this job done of painting all the ‘n’ boards under a constraint that any painter will only paint the continuous sections of boards.",
    "name": "Painter's partition",
    "topic": "bs",
    "level": "hard",
    "url": "https://www.codingninjas.com/studio/problems/painter-s-partition-problem_1089557?utm_source=striver&utm_medium=website&utm_campaign=a_zcoursetuf",
    "approach": "#same as prev",
    "pseudo_code": ""
  },
  {
    "sign_no": 65,
    "question": "You are given a sorted array ‘arr’ of length ‘n’, which contains positive integer positions of ‘n’ gas stations on the X-axis.\n\n\nYou are also given an integer ‘k’.\n\n\nYou have to place 'k' new gas stations on the X-axis.\n\n\nYou can place them anywhere on the non-negative side of the X-axis, even on non-integer positions.\n\n\nLet 'dist' be the maximum value of the distance between adjacent gas stations after adding 'k' new gas stations.\n\nFind the minimum value of dist.",
    "name": "Minimize Max Distance to Gas Station",
    "topic": "bs",
    "level": "hard",
    "url": "https://leetcode.com/problems/minimize-max-distance-to-gas-station/",
    "approach": "we have a sorted array and have to find our the maximum after minimizing the distance\nthree approaches are there\n1. brute force -> \nwe have to find the max distance between all the stations such that we can put some stations in between them so the max distance get minimum...\nto do this we loop k times for k stations then inside it we have to find the max distance ..we have to take a array to determine how many new station we have put between any index...such that the initial distance will be divided according to the number of station in between. here -> currentMaxDistance for a index is InitialDistance / ( number of stations + 1);\nand if the current distance is maximum out of all then we can add 1 more station in it to make is lesser..so putter[index]++;\nthen we move to next k...after putting all the k's then we have to find out the max distance (current distance) that will be initial / (no. of station + 1);\n\n2. -> using priority queue....\nwe can use priority queue instead of searching for maximum again and again in o(n) time so we can use priority queue to store the current distance and its index.\nso by index we can get putter[index] and update it...then we can again push the new updated current distance after adding the station and index to pq...so at then end the top of the index will be our maximum distance.\n\n3. using binary search....\nwe can use binary search on answers as we have to find the maximum of minimum distance possible...\nhere low = 0 as the distance can be zero and high will be the max distance between any two given stations..as we have to put station in between to minimise the distance.\n\nIMP.. we can't use low <= high or high = mid-1 or low = mid + 1 in this as the given answer is in double so we use a different approch and condition in loop..\nwe will loop until the difference between high - low > 10^-6 (because the tester checks upto 10^-6 th digit in case of double or float (unless given question);\nso for each mid we have to check if its our possible ans or not and to do that we make a function that will find out the number of station required so our max distance is mid...\nnosreq = (arr[i+1] - arr[i]) / mid;....here's a cache..let 0,1 be given station and for 0.4 as mid we have to put 2 station but for 0.5 we have to put 1 station but here itss 2 ...so if the difference % mid == 0 then nosreq--;\nthen we can add it to our ans variable as ans += nosreq;\n\nif the requiredStations are greater then k then we have to increase the distance so low = mid else high = mid...not mid + 1 or mid - 1 as we are working with double here..\nat the end the high will be our ans.",
    "pseudo_code": "#priority queue \n\nFunction minimiseMaxDistance(arr: vector<int>, k: int) -> double:\nn := length of arr\nputted := an array of size n - 1 filled with zeros\npq := a priority queue of pairs of doubles and integers\n\nFor i from 0 to n - 2:\nPush the pair (arr[i + 1] - arr[i], i) onto pq\n\nFor i from 0 to k - 1:\ntop := the top element of pq\npq.pop()\nind := the second element of top\ninitialDistance := arr[ind + 1] - arr[ind]\nIncrement putted[ind] by 1\ncurrentDistance := initialDistance / (putted[ind] + 1)\nPush the pair (currentDistance, ind) onto pq\n\nReturn the first element of the top element of pq\n\n\n#binary search\n\nFunction howManyNeeded(arr: vector<int>, maxDistance: double) -> int:\nans := 0\nn := length of arr\nFor i from 0 to n - 2:\nnumberInBetween := (arr[i + 1] - arr[i]) / maxDistance\nIf arr[i + 1] - arr[i] is divisible by maxDistance:\nDecrement numberInBetween by 1\nIncrement ans by numberInBetween\nReturn ans\n\nFunction minimiseMaxDistance(arr: vector<int>, k: int) -> double:\nn := length of arr\nlow := 0, high := 0\nFor i from 0 to n - 2:\nhigh := maximum of high and (arr[i + 1] - arr[i])\ndiff := a small positive value, e.g., 1e-6\n\nWhile high - low > diff:\nmid := (low + high) / 2.0\nneededStations := howManyNeeded(arr, mid)\nIf neededStations > k:\nlow := mid\nElse:\nhigh := mid\nReturn high"
  },
  {
    "sign_no": 66,
    "question": "Given two sorted arrays 'a' and 'b' of size 'n' and 'm' respectively.\n\n\nFind the median of the two sorted arrays.\n\n\nMedian is defined as the middle value of a sorted list of numbers. In case the length of list is even, median is the average of the two middle elements.\n\n\nThe expected time complexity is O(min(logn, logm)), where 'n' and 'm' are the sizes of arrays 'a' and 'b', respectively, and the expected space complexity is O(1).",
    "name": "Median of 2 sorted arrays",
    "topic": "bs",
    "level": "hard",
    "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/",
    "approach": "instead of using extra space and time we use binary search to do it in min(logn, logm) complexity.\nto do that we divide the array in 2 parts hypotitacilly so left and right part..we take elemetns from both the array such that left part < right part hence the new hypotatical array is sorted.\nthe low = 0 and high will be n and we have to take total of (n+m+1)/2 elements on left half\nfor each mid we take all element of array a before mid and similer for mid2 for array be...as mid2 will be left - mid1;\nfor odd the median will be max(l1, l2) and for even it will be (max(l1, l2) + min(r1, r2))/2;\nhere l1 is the element from array a and l2 from b and r1 from a, r2 from b.\nboth left and right part will only be correct if and only if l1<= r2 and l2 <= r1 and if l1 > r2 then we have to take less elements from array 1 hence high = mid-1; else low = mid+1;\n\nas we have to do it in min of log n or log m and to do that we take the smallest array to perform BS.",
    "pseudo_code": "Function median(a: vector<int>, b: vector<int>) -> double:\nInitialize n1 as the size of vector a\nInitialize n2 as the size of vector b\n\nIf n1 > n2:\nReturn median(b, a)\n\nInitialize n as the sum of n1 and n2\nInitialize left as the floor of (n1 + n2 + 1) / 2\n\nInitialize low as 0\nInitialize high as n1\n\nWhile low <= high:\nInitialize mid1 as the average of low and high\nInitialize mid2 as the value of left minus mid1\n\nInitialize l1 as INT_MIN\nInitialize l2 as INT_MIN\nInitialize r1 as INT_MAX\nInitialize r2 as INT_MAX\n\nIf n1 is greater than mid1:\nSet r1 to the value at index mid1 in vector a\nIf n2 is greater than mid2:\nSet r2 to the value at index mid2 in vector b\nIf mid1 - 1 is greater than or equal to 0:\nSet l1 to the value at index mid1 - 1 in vector a\nIf mid2 - 1 is greater than or equal to 0:\nSet l2 to the value at index mid2 - 1 in vector b\n\nIf l1 <= r2 and l2 <= r1:\nIf n is odd:\nReturn the maximum of l1 and l2\nElse:\nReturn the average of the maximum of l1 and l2 and the minimum of r1 and r2\n\nElse if l1 > r2:\nUpdate high as mid1 - 1\nElse:\nUpdate low as mid1 + 1\n\nReturn 0"
  },
  {
    "sign_no": 67,
    "question": "You're given two sorted arrays 'arr1' and 'arr2' of size 'n' and 'm' respectively and an element 'k'.\n\n\nFind the element that would be at the 'kth' position of the combined sorted array.\n\n\nPosition 'k' is given according to 1 - based indexing, but arrays 'arr1' and 'arr2' are using 0 - based indexing.",
    "name": "Kth element of 2 sorted arrays",
    "topic": "bs",
    "level": "medium",
    "url": "https://bit.ly/3Amcomr",
    "approach": "we have 2 sorted arrays...and find the kth element...\nto do that we have to take excatly K element in left part and remaining to right part \nso our target element is at the end of left part\nso we find how many elements we can take from the smaller array..let n , m and n < m..size of both arrays\nhere we can either select 0 element from array a but the low will be (k-m) such that if k > m then we must have to select some elements from array a..so low = max(0, k-m) and high will be min(k, n);\nnow loop and take mid1 ..then mid 2 will be k - mid1;\nthen store the l1, l2, r1, and r2 and compare them ..if l1 > r2 then high = mid1 - 1...take less elements from array a...else low = mid1 + 1;....take more element from array a...",
    "pseudo_code": "Function kthElement(a: vector<int>, b: vector<int>, n: int, m: int, k: int) -> int:\nIf n > m:\nReturn kthElement(b, a, m, n, k)\n\nInitialize low as the maximum of 0 and k - m\nInitialize high as the minimum of k and n\n\nWhile low <= high:\nInitialize mid1 as the average of low and high\nInitialize mid2 as the value of k minus mid1\n\nInitialize l1 as INT_MIN\nInitialize l2 as INT_MIN\nInitialize r1 as INT_MAX\nInitialize r2 as INT_MAX\n\nIf mid1 is less than n:\nSet r1 to the value at index mid1 in vector a\nIf mid2 is less than m:\nSet r2 to the value at index mid2 in vector b\nIf mid1 - 1 is greater than or equal to 0:\nSet l1 to the value at index mid1 - 1 in vector a\nIf mid2 - 1 is greater than or equal to 0:\nSet l2 to the value at index mid2 - 1 in vector b\n\nIf l1 <= r2 and l2 <= r1:\nReturn the maximum of l1 and l2\n\nElse if l1 > r2:\nUpdate high as mid1 - 1\nElse:\nUpdate low as mid1 + 1\n\nReturn 1"
  },
  {
    "sign_no": 68,
    "question": "You are given a 2D matrix 'ARR' (containing either ‘0’ or ‘1’) of size 'N' x 'M', where each row is in sorted order.\n\n\nFind the 0-based index of the first row with the maximum number of 1's.\n\n\nNote :\n\nIf two rows have the same number of 1’s, return the row with a lower index.\n\nIf no row exists where at-least one '1' is present, return -1.",
    "name": "Find the row with maximum number of 1's",
    "topic": "bs",
    "level": "easy",
    "url": "https://bit.ly/3QNDw2W",
    "approach": "we have 2d array where each array inside contains 0 and 1 and is sorted and we have to find the row which has max ones\nto do this using binary search we have to iterate the 2d array and we can apply the BS on inner array as its sorted and we can find out the number of occurences using binary search.....\nso we have the ans = - 1 initial...and for each row we have to find the first orrurence of 1 so the total ones in the array will be n - index;\nthe we can update the ans accordingly (index of row) that has max number of ones..",
    "pseudo_code": "Function rowWithMax1s(a: vector<vector<int>>, n: int, m: int) -> int:\nans := -1, maxOne := 0\n\nFor i from 0 to n - 1:\nlow := 0, high := m - 1\nwhile low <= high:\nmid := (low + high) / 2\nIf a[i][mid] == 1:\nhigh := mid - 1\nElse:\nlow := mid + 1\nnum := m - low\nIf num > maxOne:\nans := i\nmaxOne := num\n\nReturn ans"
  },
  {
    "sign_no": 69,
    "question": "You have been given a 2-D array 'mat' of size 'M x N' where 'M' and 'N' denote the number of rows and columns, respectively. The elements of each row are sorted in non-decreasing order.\n\n\nMoreover, the first element of a row is greater than the last element of the previous row (if it exists).\n\n\nYou are given an integer ‘target’, and your task is to find if it exists in the given 'mat' or not.",
    "name": "Search in a 2 D matrix",
    "topic": "bs",
    "level": "medium",
    "url": "https://leetcode.com/problems/search-a-2d-matrix/",
    "approach": "as each row is sorted in matrix and to find the target..\nlet low = 0 and high = n*m -1; (zero based numbering);\nfor each mid we have to convert that mid to its row and col value such that we can compare and act accordingly.\nso row = m / mid; and col = m % mid;\nwe check if a[row[[col] == target then return true;\nif is less then eliminate left half else eliminate right half",
    "pseudo_code": "Function searchMatrix(mat: vector<vector<int>>, target: int) -> bool:\nn := mat.size()\nm := mat[0].size()\nlow := 0\nhigh := n * m - 1\n\nWhile low <= high:\nmid := (low + high) / 2\nrow := mid / m\ncol := mid % m\n\nIf mat[row][col] == target:\nReturn true\nElse If mat[row][col] > target:\nhigh := mid - 1\nElse:\nlow := mid + 1\n\nReturn false"
  },
  {
    "sign_no": 70,
    "question": "You are given a 2D matrix ‘MATRIX’ of ‘N’*’M’ dimension. You must check whether a given number ‘target’ is present in the matrix.\n\n\nThe following properties apply to the given matrix:\n\n1. In each row, integers are sorted from left to right.\n2. Each row's first integer is greater than the previous row's last integer.\n\nExample:\n\nInput:\n'MATRIX' = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60] ], 'TARGET' = 3 \nOutput:1\nExplanation: Since the given number ‘TARGET’ is present in the matrix, we return true.",
    "name": "Search in a row and column wise sorted matrix",
    "topic": "bs",
    "level": "medium",
    "url": "https://leetcode.com/problems/search-a-2d-matrix-ii/",
    "approach": "same as prev",
    "pseudo_code": ""
  },
  {
    "sign_no": 71,
    "question": "You are given a 0-indexed 2-D grid ‘g’ of size ‘n’ X ‘m’, where each cell contains a positive integer, and adjacent cells are distinct.\n\n\nYou need to find the location of a peak element in it. If there are multiple answers, find any of them.\n\n\nA peak element is a cell with a value strictly greater than all its adjacent cells.\n\n\nAssume the grid to be surrounded by a perimeter of ‘-1s’.\n\n\nYou must write an algorithm that works in O(n * log(m)) or O(m * log(n)) complexity.\n\n\nNote:\n\nIn the output, you will see '0' or '1', where '0' means your answer is wrong, and '1' means your answer is correct.",
    "name": "Find Peak Element (2D Matrix)",
    "topic": "bs",
    "level": "hard",
    "url": "https://leetcode.com/problems/find-a-peak-element-ii/",
    "approach": "we have 2d matriix..giveen n and m;\nwe can not use BS directly but we can use BS on columns ... 0 to m if we know the max value of that column\nlow = 0 and high = m -1;\nfor each mid we have to find the max element in that column (mid) index ...so we don't have to check it with the top and bottom adjacent element as its max of column so we just have to check it with the left and right..so we have the row index of max of column so we can take left as ind - 1 and right as ind + 1..check if overflow as given if left < 0 then -1 and right >= m then also -1 so now we can compare the element at left , right with the current [max of col][mid] ..if its greater then both then return them\nelse if its lesser then left then eliminate right half..high = mid - 1 else low = mid + 1;",
    "pseudo_code": "Function findMax(a: vector<vector<int>>, n: int, col: int) -> int:\nmaxi := INT_MIN\nmaxInd := -1\n\nFor i from 0 to n-1:\nIf a[i][col] > maxi:\nmaxInd := i\nmaxi := a[i][col]\n\nReturn maxInd\n\nFunction findPeakGrid(a: vector<vector<int>>) -> vector<int>:\nn := a.size()\nm := a[0].size()\nlow := 0\nhigh := m - 1\n\nWhile low <= high:\nmid := (low + high) / 2\nmri := findMax(a, n, mid)\nleft := mid - 1 >= 0 ? a[mri][mid - 1] : -1\nright := mid + 1 < m ? a[mri][mid + 1] : -1\n\nIf a[mri][mid] > left && a[mri][mid] > right:\nReturn {mri, mid}\nElse If a[mri][mid] < left:\nhigh := mid - 1\nElse:\nlow := mid + 1\n\nReturn {-1, -1}"
  },
  {
    "sign_no": 72,
    "question": "You are given a row-wise sorted matrix 'mat' of size m x n where 'm' and 'n' are the numbers of rows and columns of the matrix, respectively.\n\n\nYour task is to find and return the median of the matrix.\n\n\nNote:\n\n'm' and 'n' will always be odd.",
    "name": "Matrix Median",
    "topic": "bs",
    "level": "hard",
    "url": "https://bit.ly/3PvwuPk",
    "approach": "given rowwise sorted matrix...have to find median...\ncan be done using brute force but it will take extra space and time...but we can do it using BS\nhow ? if we know the number of element that are less than the given number then we can take a req var = n*m / 2;\nsuch that we have to find a number that is greater then req number of elements in the matrix....let low be 0 and high be 1e9;\nfor each mid we have to find the number of elements that are lesser or equal to mid...to do that we can loop through all rows and find the upper bound of mid ..upper bound of mid will tell the number of elements that are less or equal to mid so we can add the upper bound of each row to an ans variable...denoting total numbers that are lesser then or equal to mid\n\nif total number <= req then eliminate the left half as low = mid + 1;\nelse high = mid - 1;\n\nat the end low will be our ans.",
    "pseudo_code": "Function upperBound(a: vector<int>, mid: int) -> int:\nn := a.size()\nlow := 0\nhigh := n - 1\nans := n\n\nWhile low <= high:\nmd := (low + high) / 2\n\nIf a[md] > mid:\nans := md\nhigh := md - 1\nElse:\nlow := md + 1\n\nReturn ans\n\nFunction countSmaller(a: vector<vector<int>>, mid: int) -> int:\ncnt := 0\nn := a.size()\nm := a[0].size()\n\nFor i from 0 to n-1:\ncnt += upperBound(a[i], mid)\n\nReturn cnt\n\nFunction median(matrix: vector<vector<int>>, m: int, n: int) -> int:\nlow := 1\nhigh := 1e9\nreq := (m * n) / 2\n\nWhile low <= high:\nmid := (low + high) / 2\ncnt := countSmaller(matrix, mid)\n\nIf cnt <= req:\nlow := mid + 1\nElse:\nhigh := mid - 1\n\nReturn low"
  },
  {
    "sign_no": 88,
    "question": "You are given an array ‘Arr’ of size ‘N’ consisting of positive integers.\n\n\nMake a linked list from the array and return the head of the linked list.\n\n\nThe head of the linked list is the first element of the array, and the tail of the linked list is the last element.\n\n\nNote:\n\nIn the output, you will see the elements of the linked list made by you.",
    "name": "Introduction to LinkedList, learn about struct, and how is node represented",
    "topic": "ll",
    "level": "easy",
    "url": "https://bit.ly/3URZnst",
    "approach": "make a new node then iterate through array and have a another node pointing to head..this another node will be used to add new nodes to end of list so our head remain at place and we can return the head.",
    "pseudo_code": "Function constructLL(arr: vector<int>) -> Node*:\ndummy := new Node(-1)\ntemp := dummy\n\nFor i from 0 to arr.size() - 1:\nnewNode := new Node(arr[i])\ntemp.next := newNode\ntemp := newNode\n\nReturn dummy.next"
  },
  {
    "sign_no": 89,
    "question": "You are given the head of a linked list ‘list’ of size ‘N’ and an integer ‘newValue’.\n\n\nYour task is to insert a node with the value ‘newValue’ at the beginning of the ‘list’ and return the new head of the linked list.\n\n\nYou must write an algorithm whose time complexity is O(1) and whose space complexity is O(1).\n\n\nNote:\n\nIn the output, you will see the elements of the linked list made by you.",
    "name": "Inserting a node in LinkedList",
    "topic": "ll",
    "level": "easy",
    "url": "https://bit.ly/3w9pEIt",
    "approach": "new node...new node ->next = list...return newnode",
    "pseudo_code": ""
  },
  {
    "sign_no": 90,
    "question": "You are given the head of a linked list ‘list’ of size ‘N’.\n\n\nYour task is to delete the linked list's last node and return the linked list's head.",
    "name": "Deleting a node in LinkedList",
    "topic": "ll",
    "level": "medium",
    "url": "https://leetcode.com/problems/delete-node-in-a-linked-list/",
    "approach": "inorder to delete the last node we have to go to last 2nd node then we can delete the last node easily.",
    "pseudo_code": "Node *deleteLast(Node *list){\nNode* temp = list;\n\nwhile(temp->next && temp->next->next){\ntemp = temp-> next;\n}\nNode* todel = temp->next;\ndelete todel;\ntemp->next = nullptr;\nreturn list;\n}"
  },
  {
    "sign_no": 91,
    "question": "Given the head of a singly linked list of integers, find and return its length.",
    "name": "Find the length of the linkedlist [learn traversal]",
    "topic": "ll",
    "level": "easy",
    "url": "https://bit.ly/3Po7tpf",
    "approach": "iterate and count",
    "pseudo_code": ""
  },
  {
    "sign_no": 92,
    "question": "You are given a Singly Linked List of integers with a head pointer. Every node of the Linked List has a value written on it.\n\n\nA sample Linked List:\n\n\nNow you have been given an integer value, 'K'. Your task is to check whether a node with a value equal to 'K' exists in the given linked list. Return 1 if node exists else return 0.",
    "name": "Search an element in the LL",
    "topic": "ll",
    "level": "easy",
    "url": "https://bit.ly/3Epriup",
    "approach": "iterate till temp is not null and check the value with target.",
    "pseudo_code": ""
  },
  {
    "sign_no": 93,
    "question": "You are given an array ‘Arr’ of size ‘N’ consisting of positive integers.\n\n\nYour task is to make a doubly linked list from the array and return the head of the linked list.\n\n\nHere, the head of the doubly linked list is the first element of the array, and the tail of the doubly linked list is the last element.\n\n\nNote:\n\nA doubly linked list is one in which it is possible to access the next and the previous nodes from a node in the linked list (if they exist).",
    "name": "Introduction to DLL, learn about struct, and how is node represented",
    "topic": "ll",
    "level": "easy",
    "url": "https://bit.ly/3V9wY1v",
    "approach": "take two node let head and tail...we have to add new nodes to tail inorder to convert array to doubly linked list...\nalso we have to take care of new nodes ->prev = temp then iterate through temp .",
    "pseudo_code": ""
  },
  {
    "sign_no": 94,
    "question": "A doubly-linked list is a data structure that consists of sequentially linked nodes, and the nodes have reference to both the previous and the next nodes in the sequence of nodes.\n\n\nGiven a doubly-linked list and a value ‘k’, insert a node having value ‘k’ at the end of the doubly linked list.\n\n\nNote:\n\nYou need not print anything. You’re given the head of the linked list. Return the head of the modified list.",
    "name": "Insert a node in DLL",
    "topic": "ll",
    "level": "easy",
    "url": "https://bit.ly/3QD4hHs",
    "approach": "iterate to the last node then add a new node there ...and newnode -> prev =temp ...as its doubly LL",
    "pseudo_code": ""
  },
  {
    "sign_no": 95,
    "question": "A doubly-linked list is a data structure that consists of sequentially linked nodes, and the nodes have reference to both the previous and the next nodes in the sequence of nodes.\n\n\nGiven a doubly-linked list, delete the node at the end of the doubly linked list.\n\n\nNote:\n\nYou need not print anything. You’re given the head of the linked list, just return the head of the modified list.",
    "name": "Delete a node in DLL",
    "topic": "ll",
    "level": "medium",
    "url": "https://bit.ly/3QlEoMx",
    "approach": "if head is the only node then delete head and return NULL\nelse traverse to last node...store the prev node delete last node and set prev nodes next to null",
    "pseudo_code": ""
  },
  {
    "sign_no": 96,
    "question": "You are given a doubly-linked list of size 'N', consisting of positive integers. Now your task is to reverse it and return the head of the modified list.\n\n\nNote:\n\nA doubly linked list is a kind of linked list that is bidirectional, meaning it can be traversed in both forward and backward directions.",
    "name": "Reverse a DLL",
    "topic": "ll",
    "level": "medium",
    "url": "https://bit.ly/3w6hUaa",
    "approach": "take two nodes..temp and last...\niterate while temp...\nset last to prev of temp then set temp.prev to next of temp\nand temp.next to last (changing links to reverse DLL) then set temp to next (now at prev)",
    "pseudo_code": ""
  },
  {
    "sign_no": 97,
    "question": "Given a singly linked list of 'N' nodes. The objective is to determine the middle node of a singly linked list. However, if the list has an even number of nodes, we return the second middle node.",
    "name": "Middle of a LinkedList [TortoiseHare Method]",
    "topic": "ll",
    "level": "easy",
    "url": "https://leetcode.com/problems/middle-of-the-linked-list/",
    "approach": "take two pointers..fast and slow..move fast to 2 steps and slow to 1 step..if fast is at last node then our slow is at center of linkedlist.",
    "pseudo_code": ""
  },
  {
    "sign_no": 98,
    "question": "You are given a Singly Linked List of integers. You need to reverse the Linked List by changing the links between nodes.",
    "name": "Reverse a LinkedList [Iterative]",
    "topic": "ll",
    "level": "easy",
    "url": "https://leetcode.com/problems/reverse-linked-list/",
    "approach": "take three pointers last, next and current....so we can store the next..then change current's next to last..then last to current and current to next ...at the end our last will be the head of the new LL.",
    "pseudo_code": ""
  },
  {
    "sign_no": 99,
    "question": "You are given a Singly Linked List of integers. You need to reverse the Linked List by changing the links between nodes.",
    "name": "Reverse a LL [Recursive]",
    "topic": "ll",
    "level": "easy",
    "url": "https://leetcode.com/problems/reverse-linked-list/",
    "approach": "useing recursion....\ncheck if the head or head->next is null in that case we return the head\nour function will return the new head after reversing the LL...\nin recursion we pass head->next...so at that point the function returns the reversed LL upto head->next..now we have a new head for reversed LL (partially) now for the current head we have to change the links..as head->next points to the last element of the reverse LL and the last point to NULL so we have to point that last to our current head element and head->next to NULL then we can return the newnode (head of reversed LL);",
    "pseudo_code": "Function reverseLinkedList(head: Node) -> Node*:\n// Base case: if head is NULL or head->next is NULL, return head\nIf head is NULL OR head->next is NULL:\nReturn head\n\n// Recursive call to reverseLinkedList with head->next\nnewHead := reverseLinkedList(head->next)\n\n// Reverse the link between head and head->next\nfront := head->next\nfront->next := head\nhead->next := NULL\n\n// Return the new head of the reversed linked list\nReturn newHead"
  },
  {
    "sign_no": 100,
    "question": "You are given a Singly Linked List of integers. Return true if it has a cycle, else return false.\n\n\nA cycle occurs when a node's next points back to a previous node in the list.",
    "name": "Detect a loop in LL",
    "topic": "ll",
    "level": "medium",
    "url": "https://leetcode.com/problems/linked-list-cycle/",
    "approach": "use fast and slow pointer method..if the LL has cycle then the fast will meet slow at some point..if they don't meet and fast become null then that means there is no cycle",
    "pseudo_code": "Function detectCycle(head: Node) -> bool:\n// Base case: if head or head->next is NULL, return false\nIf head is NULL OR head->next is NULL:\nReturn false\n\n// Initialize slow and fast pointers\nslow := head\nfast := head\n\n// Loop until fast pointer reaches end of list\nWhile fast is not NULL AND fast->next is not NULL:\n// Move slow pointer one step forward\nslow := slow->next\n// Move fast pointer two steps forward\nfast := fast->next->next\n// If slow and fast pointers meet, there is a cycle, return true\nIf slow == fast:\nReturn true\n\n// If loop terminates without detecting cycle, return false\nReturn false"
  },
  {
    "sign_no": 101,
    "question": "You are given a singly linked list that may or may not contain a cycle. You are supposed to return the node where the cycle begins, if a cycle exists, else return 'NULL'.\n\n\nA cycle occurs when a node's next pointer returns to a previous node in the list.",
    "name": "Find the starting point in LL",
    "topic": "ll",
    "level": "medium",
    "url": "https://leetcode.com/problems/linked-list-cycle-ii/",
    "approach": "to find the start of the cycle ...we can use map..but it will take extra space ..\nhowever we can use fast and slow pointer to find the start ....\nloop while fast and fast->next...if fast and slow collide then that is our collision point...\nthe distance from the colliosion point to start of cycle and the distance from start to start of cycle will be same\nso put slow to start...then loop again while slow and fast collide again...this time fast and slow should move 1 step at a time...\nthe point of their recollision will be our start of cycle.\n\nto find out why they collide ..watch the video explanation of striver",
    "pseudo_code": "Function firstNode(head: Node) -> Node:\n// Base case: if head or head->next is NULL, return NULL\nIf head is NULL OR head->next is NULL:\nReturn NULL\n\n// Initialize slow and fast pointers\nslow := head\nfast := head\n\n// Loop until fast pointer reaches end of list\nWhile fast is not NULL AND fast->next is not NULL:\n// Move slow pointer one step forward\nslow := slow->next\n// Move fast pointer two steps forward\nfast := fast->next->next\n// If slow and fast pointers meet, there is a cycle\nIf slow == fast:\n// Reset slow pointer to head\nslow := head\n// Loop until slow and fast pointers meet again\nWhile slow != fast:\n// Move slow and fast pointers one step forward\nslow := slow->next\nfast := fast->next\n// Return the first node of the cycle\nReturn slow\n\n// If loop terminates without detecting cycle, return NULL\nReturn NULL"
  },
  {
    "sign_no": 102,
    "question": "You’re given a linked list. The last node might point to null, or it might point to a node in the list, thus forming a cycle.\n\n\nFind out whether the linked list has a cycle or not, and the length of the cycle if it does.\n\n\nIf there is no cycle, return 0, otherwise return the length of the cycle.",
    "name": "Length of Loop in LL",
    "topic": "ll",
    "level": "easy",
    "url": "https://bit.ly/3dyXL6m",
    "approach": "loop..take fast and slow..if they collide..\nmake slow = slow->next;;;loop again until they collide again this time with a counter..at the end the counter will be our ans",
    "pseudo_code": ""
  },
  {
    "sign_no": 103,
    "question": "You are given a Singly Linked List of integers. You have to return true if the linked list is palindrome, else return false.\n\n\nA Linked List is a palindrome if it reads the same from left to right and from right to left.",
    "name": "Check if LL is palindrome or not",
    "topic": "ll",
    "level": "medium",
    "url": "https://leetcode.com/problems/palindrome-linked-list/",
    "approach": "take fast slow..get slow to the middle..then reverse the list from slow->next to end\nthen compare the new reversed half list to start of the list ..if they are not same then fasle...at end return true;",
    "pseudo_code": "Function reverseLinkedList(head: Node) -> Node:\n// Base case: if head or head->next is NULL, return head\nIf head is NULL OR head->next is NULL:\nReturn head\n\n// Recursively reverse the rest of the linked list\nnewHead := reverseLinkedList(head->next)\n// Reverse the link between head and its next node\nhead->next->next := head\nhead->next := NULL\n// Return the new head of the reversed linked list\nReturn newHead\n\n\nFunction isPalindrome(head: Node) -> Boolean:\n// Base case: if head or head->next is NULL, return true\nIf head is NULL OR head->next is NULL:\nReturn true\n\n// Initialize slow and fast pointers to find the middle of the linked list\nslow := head\nfast := head\n// Move slow pointer one step forward and fast pointer two steps forward until fast reaches the end of the list\nWhile fast is not NULL AND fast->next is not NULL:\nslow := slow->next\nfast := fast->next->next\n\n// Reverse the second half of the linked list starting from slow->next\nsecondHalf := reverseLinkedList(slow->next)\n\n// Compare the first half of the linked list with the reversed second half\nfirstHalf := head\nWhile secondHalf is not NULL:\nIf firstHalf->data is not equal to secondHalf->data:\nReturn false\nfirstHalf := firstHalf->next\nsecondHalf := secondHalf->next\n\n// If the loop completes without finding any mismatch, the linked list is a palindrome\nReturn true"
  },
  {
    "sign_no": 104,
    "question": "You are given the head node of a singly linked list 'head'. Your task is to modify the linked list in such a way that all the even valued nodes appear before the all odd valued node and order of nodes remain the same.",
    "name": "Segrregate odd and even nodes in LL",
    "topic": "ll",
    "level": "medium",
    "url": "https://leetcode.com/problems/odd-even-linked-list/",
    "approach": "take two nodes..we will be making list of nodes that contain even and one containing odd...at the end we can attach both to have a single list .",
    "pseudo_code": "Function segregateEvenOdd(head: Node) -> Node:\n// Initialize pointers\neven = NULL\nodd = NULL\nevenLast = NULL\noddLast = NULL\ntemp = head\n\n// Traverse the original list\nWhile temp is not NULL:\nIf temp->data is even:\nIf evenLast is not NULL:\nAppend temp to even list after evenLast\nUpdate evenLast to temp\nElse:\nSet even as temp and evenLast as temp\nElse:\nIf oddLast is not NULL:\nAppend temp to odd list after oddLast\nUpdate oddLast to temp\nElse:\nSet odd as temp and oddLast as temp\nMove temp to the next node\n\n// Connect even and odd lists\nConnect evenLast to the first node of the odd list\nSet oddLast's next pointer to NULL\n\n// Return the head of the even list\nReturn even"
  },
  {
    "sign_no": 105,
    "question": "You have been given a singly Linked List of 'N' nodes with integer data and an integer 'K'.\n\n\nYour task is to remove the 'K'th node from the end of the given Linked List and return the head of the modified linked list.",
    "name": "Remove Nth node from the back of the LL",
    "topic": "ll",
    "level": "medium",
    "url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/",
    "approach": "we have to delete the kth elelement from end..so it will be n-k+1 th element from start...\nand to delete that element we have to go to the prev of that element so n-k-1 times loop ot go to that node...\nthen we can change the links and delete the kth node..\nalso take care if n == k that means we have to delete the head...",
    "pseudo_code": "function findLength(head: Node) -> integer:\n// Initialize temporary pointer and length counter\ntemp := head\nlen := 0\n\n// Traverse the linked list and count the nodes\nwhile temp is not NULL:\ntemp := temp->next\nlen := len + 1\n\n// Return the length of the linked list\nreturn len\n\nfunction removeKthNode(head: Node, k: integer) -> Node:\n// Check if the linked list is empty\nif head is NULL:\nreturn NULL\n\n// Find the length of the linked list\nlen := findLength(head)\n\n// Check if k is equal to the length of the linked list\nif k is equal to len:\n// Delete the head node and return the new head\nnewHead := head->next\ndelete head\nreturn newHead\n\n// Calculate the position of the node to be deleted\nres := len - k\ntemp := head\n\n// Traverse the linked list to find the node before the node to be deleted\nwhile temp is not NULL:\nres := res - 1\nif res is equal to 0:\nbreak\ntemp := temp->next\n\n// Delete the kth node from the linked list\nnodeToDelete := temp->next\ntemp->next := temp->next->next\ndelete nodeToDelete\n\n// Return the head of the modified linked list\nreturn head"
  },
  {
    "sign_no": 106,
    "question": "Given a singly linked list of 'N' nodes. Your task is to delete the middle node of this list and return the head of the modified list.\n\n\nHowever, if the list has an even number of nodes, we delete the second middle node",
    "name": "Delete the middle node of LL",
    "topic": "ll",
    "level": "medium",
    "url": "https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/#:~:text=You%20are%20given%20the%20head,than%20or%20equal%20to%20x%20.",
    "approach": "use fast slow method...to reach to the middle node...\nand to delete it we would need to store the prev slow ...then we can easily delete the slow'th node.",
    "pseudo_code": "function deleteMiddle(head: Node) -> Node:\n// Check if the linked list contains only one node\nif head->next is NULL:\n// Delete the single node and return NULL\ndelete head\nreturn NULL\n\n// Initialize pointers to track the middle and previous nodes\nprev := NULL\nmiddle := head\nfast := head\n\n// Traverse the linked list to find the middle node\nwhile fast is not NULL and fast->next is not NULL:\nprev := middle\nmiddle := middle->next\nfast := fast->next->next\n\n// Remove the middle node from the linked list\nprev->next := middle->next\ndelete middle\n\n// Return the head of the modified linked list\nreturn head"
  },
  {
    "sign_no": 107,
    "question": "Given a linked list of 'N' nodes, which has nodes in alternating non-decreasing and non-increasing. Sort the list in non-decreasing order.\n\n\nFor Example:\n\nIf given linked list is 1->9->3->8->4 then it should be modified to 1->3->4->8->9.",
    "name": "Sort LL",
    "topic": "ll",
    "level": "medium",
    "url": "https://leetcode.com/problems/sort-list/",
    "approach": "we can sort the LL using 2 app\n\n#1 -> we can put all the element in a array then sort that array then put the elements back in order to the LL.\n\n#2 -> using merge sort technique...we divide the LL then sort them while merging them then we can return the head. (its complicated better to view the yt video or solution for better understanding)\n\nto divide the list in 2 parts..we can use slow and fast to find the middle...then we put left = head and right = middle->next..now middle node is in left ...so middle->next = NULL..so we can apply merge sort properly...\nas we will be dividing and merging...so we will have to sorted list to merge..and we know how to merge two sorted list...hence we can sort the whole list.",
    "pseudo_code": "function mergeList(left: Node, right: Node) -> Node:\n// Create a dummy node to facilitate merging\ndummyNode := new Node(-1)\ntemp := dummyNode\n\n// Merge the two sorted lists\nwhile left is not NULL and right is not NULL:\nif left->data < right->data:\ntemp->next := left\ntemp := left\nleft := left->next\nelse:\ntemp->next := right\ntemp := right\nright := right->next\n\n// Append the remaining elements of the non-empty list\nif left is not NULL:\ntemp->next := left\nelse:\ntemp->next := right\n\n// Return the merged list starting from the next of the dummy node\nreturn dummyNode->next\n\nfunction findMiddle(head: Node) -> Node:\n// Initialize slow and fast pointers to find the middle node\nslow := head\nfast := head->next\n\n// Traverse the list to find the middle node\nwhile fast is not NULL and fast->next is not NULL:\nslow := slow->next\nfast := fast->next->next\n\n// Return the middle node\nreturn slow\n\nfunction sortList(head: Node) -> Node:\n// Base case: If the list is empty or has only one node, return the list\nif head is NULL or head->next is NULL:\nreturn head\n\n// Find the middle node of the list\nmiddle := findMiddle(head)\n\n// Split the list into two halves from the middle node\nright := middle->next\nmiddle->next := NULL\n\n// Recursively sort the left and right halves of the list\nleft := sortList(head)\nright := sortList(right)\n\n// Merge the sorted left and right halves\nreturn mergeList(left, right)"
  },
  {
    "sign_no": 108,
    "question": "Given a linked list of 'N' nodes, where each node has an integer value that can be 0, 1, or 2. You need to sort the linked list in non-decreasing order and the return the head of the sorted list.",
    "name": "Sort a LL of 0's 1's and 2's by changing links",
    "topic": "ll",
    "level": "medium",
    "url": "https://bit.ly/3Ceotvr",
    "approach": "to sort the list of 0,1,2...\nwe can take three nodes and traversal nodes...for zero, one and two..\nusing temp node we can traverse the list and add the node to its corresponding value list...\nat the end we can attach the three lists together to make a sorted list...",
    "pseudo_code": "function sortList(head: Node) -> Node:\n// Base case: If the list is empty or has only one node, return the list\nif head is NULL or head->next is NULL:\nreturn head\n\n// Initialize three dummy nodes and pointers to track the end of each sublist\nzeroHead := new Node(-1)\noneHead := new Node(-1)\ntwoHead := new Node(-1)\nzeroEnd := zeroHead\noneEnd := oneHead\ntwoEnd := twoHead\ntemp := head\n\n// Traverse the original list and segregate nodes based on their data value\nwhile temp is not NULL:\nif temp->data is equal to 0:\nzeroEnd->next := temp\nzeroEnd := temp\nelse if temp->data is equal to 1:\noneEnd->next := temp\noneEnd := temp\nelse:\ntwoEnd->next := temp\ntwoEnd := temp\n\ntemp := temp->next\n\n// Connect the end of the zero sublist to the start of the one sublist\nzeroEnd->next := oneHead->next if oneHead->next is not NULL else twoHead->next\n\n// Connect the end of the one sublist to the start of the two sublist\noneEnd->next := twoHead->next\n\n// Terminate the two sublist\ntwoEnd->next := NULL\n\n// Return the head of the sorted list, which starts from the zero sublist\nreturn zeroHead->next"
  },
  {
    "sign_no": 109,
    "question": "You are given two Singly Linked Lists of integers, which may have an intersection point.\n\nYour task is to return the first intersection node. If there is no intersection, return NULL.",
    "name": "Find the intersection point of Y LL",
    "topic": "ll",
    "level": "medium",
    "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/",
    "approach": "1. we can use map to store the node of one list ..then traverse another list to find out the intersection point...\n\n2. optimal...if we put the list side by side then we can see the difference between the lengths so if somehow we start the longer list at the position difference of smaller one then if we traverse the list our pointers will meet at the intersection point...\nand to do that we have head1, head2 given..let l1, l2 the two traverser node..if l1 = null first then put l1 to head2..and if l2 is null then put l2 to head1..then continue with traversal such that if l1 and l2 collide it will be our traversal point.",
    "pseudo_code": "function findIntersection(head1: Node, head2: Node) -> Node:\n// Initialize two pointers pointing to the heads of the input lists\nd1 := head1\nd2 := head2\n\n// Traverse both lists until they meet or reach the end\nwhile d1 is not equal to d2:\n// Move both pointers one step forward\nd1 := d1->next\nd2 := d2->next\n\n// If the pointers meet, it means there is an intersection point\nif d1 is equal to d2:\nreturn d1\n\n// If either pointer reaches the end of its list, reset it to the head of the other list\nif d1 is NULL:\nd1 := head2\nelse if d2 is NULL:\nd2 := head1\n\n// If the loop terminates without finding an intersection, return NULL\nreturn d1"
  },
  {
    "sign_no": 110,
    "question": "You're given a positive integer represented in the form of a singly linked-list of digits. The length of the number is 'n'.\n\n\nAdd 1 to the number, i.e., increment the given number by one.\n\n\nThe digits are stored such that the most significant digit is at the head of the linked list and the least significant digit is at the tail of the linked list.",
    "name": "Add 1 to a number represented by LL",
    "topic": "ll",
    "level": "medium",
    "url": "https://bit.ly/3piCTD3",
    "approach": "we have to add 1 to the number...and to do that we have to take care of carry..\nso lets make a function that will check for current node value and add carry to it..so if the value > 10 then make the value 0 and return 1 as carry..and if the value is < 10 then return 0 as carry.\nand if the temp is NULL that means we have to return 1 as carry so we can add that carry to its prev node.\n\nsee the pseudo code for better intuition.",
    "pseudo_code": "function helper(temp: Node) -> int:\n// Base case: If the current node is NULL, return 1 as carry\nif temp is NULL:\nreturn 1\n\n// Recursive call to the next node, get the carry\ncarry := helper(temp->next)\n\n// Add the carry to the current node's data\ntemp->data := temp->data + carry\n\n// If the sum is less than 10, no carry is needed, return 0\nif temp->data < 10:\ntemp->data := temp->data\nreturn 0\n\n// If the sum is 10 or greater, set the current node's data to 0 and return 1 as carry\ntemp->data := 0\nreturn 1\n\nfunction addOne(head: Node) -> Node:\n// Call the helper function to add one recursively\ncarry := helper(head)\n\n// If there is a carry after adding one, create a new node with value 1 and append it to the head\nif carry is 1:\nnewNode := new Node(1)\nnewNode->next := head\nreturn newNode\n\n// If there is no carry, return the original head\nreturn head"
  },
  {
    "sign_no": 111,
    "question": "You are given two non-negative numbers 'num1' and 'num2' represented in the form of linked lists.\n\n\nThe digits in the linked lists are stored in reverse order, i.e. starting from least significant digit (LSD) to the most significant digit (MSD), and each of their nodes contains a single digit.\n\n\nCalculate the sum of the two numbers and return the head of the sum list.",
    "name": "Add 2 numbers in LL",
    "topic": "ll",
    "level": "medium",
    "url": "https://leetcode.com/problems/add-two-numbers/",
    "approach": "the given two list are already in lead to most significant order...so we can just iterate from head..\ninitialy the carry wil be 0..and we loop until both of the list traversal node is not NULL ...\nwe will add the data of both nodes and carry...then we can check if the data > 9 then the value that should be in data is data % 10 and the carry will be 1 if the values are not > 9 then carry is 0.\nif the carry remains after all the iteration that means we have to add an extra node to the sun list end containing 1 as its value.",
    "pseudo_code": "function addTwoNumbers(num1: Node, num2: Node) -> Node:\n// Create a dummy node to hold the result\ndummy := new Node(-1)\nnewEnd := dummy\ncarry := 0\n\n// Loop until both lists are traversed\nwhile num1 is not NULL or num2 is not NULL:\n// Create a new node for the sum\nnewNode := new Node()\n\n// Calculate the sum of current digits and the carry\nif num1 is not NULL and num2 is not NULL:\nnewNode->data := num1->data + num2->data + carry\nnum1 := num1->next\nnum2 := num2->next\nelse if num1 is not NULL:\nnewNode->data := num1->data + carry\nnum1 := num1->next\nelse:\nnewNode->data := num2->data + carry\nnum2 := num2->next\n\n// Update carry based on the sum\nif newNode->data > 9:\nnewNode->data := newNode->data % 10\ncarry := 1\nelse:\ncarry := 0\n\n// Append the new node to the result list\nnewEnd->next := newNode\nnewEnd := newNode\n\n// If there is a carry after traversing both lists, add an extra node\nif carry is 1:\nextraNode := new Node(1)\nnewEnd->next := extraNode\n\n// Return the head of the resulting list (excluding the dummy node)\nreturn dummy->next"
  },
  {
    "sign_no": 112,
    "question": "A doubly-linked list is a data structure that consists of sequentially linked nodes, and the nodes have reference to both the previous and the next nodes in the sequence of nodes.\n\n\nYou’re given a doubly-linked list and a key 'k'.\n\n\nDelete all the nodes having data equal to ‘k’.",
    "name": "Delete all occurrences of a key in DLL",
    "topic": "ll",
    "level": "medium",
    "url": "https://bit.ly/3zuBr66",
    "approach": "traverse the list...as its a DLL we have to take care of the prev and next nodes...\ncheck if the node data is equal to target...it it is then ...if its head then we have to take care of head node too..\nif not then check if prev exists then update the prev's next link to current next and if next exists then update next's prev link to current prev..then delete the node from memory...",
    "pseudo_code": "function deleteAllOccurrences(head: Node*, k: int) -> Node*:\n// Check if the list is empty\nif head is NULL:\nreturn NULL\n\n// Initialize a temporary pointer to traverse the list\ntemp := head\n\n// Traverse the list\nwhile temp is not NULL:\n// Check if the current node's data matches the value to delete (k)\nif temp->data is equal to k:\n// Save the reference to the node to delete\nnodeToDel := temp\n\n// Update the head pointer if the node to delete is the first node\nif head is equal to nodeToDel:\nhead := nodeToDel->next\n\n// Update the previous node's next pointer\nif nodeToDel->prev is not NULL:\nnodeToDel->prev->next := nodeToDel->next\n\n// Update the next node's previous pointer\nif nodeToDel->next is not NULL:\nnodeToDel->next->prev := nodeToDel->prev\n\n// Delete the node\ndelete nodeToDel\n\n// Move to the next node\ntemp := temp->next\n\n// Return the updated head pointer\nreturn head"
  },
  {
    "sign_no": 113,
    "question": "A doubly-linked list is a data structure that consists of sequentially linked nodes, and the nodes have reference to both the previous and the next nodes in the sequence of nodes.\n\n\nYou are given a sorted doubly linked list of size 'n', consisting of distinct positive integers, and a number 'k'.\n\n\nFind out all the pairs in the doubly linked list with sum equal to 'k'.",
    "name": "Find pairs with given sum in DLL",
    "topic": "ll",
    "level": "medium",
    "url": "https://bit.ly/3zWPiBj",
    "approach": "here we can use two pointer approach to find the pairs in sorted array..\nbut we have to first point our pointer to the last node of DLL..\nthen while left != right we can loop and check for sum of both nodes data and compare the target.\nif equal then puush the pair to ans and left to next;\nif sum > target that means we have to take smaller elements fo right to prev\nelse left to next;",
    "pseudo_code": "function findPairs(head: Node*, k: int) -> vector<pair<int, int>>:\n// Initialize two pointers, left and right, to traverse the list\nleft := head\nright := head\n\n// Initialize an empty vector to store pairs of nodes\nans := empty vector<pair<int, int>>\n\n// Move the right pointer to the end of the list\nwhile right->next is not NULL:\nright := right->next\n\n// Loop until the left and right pointers meet\nwhile right is not equal to left:\n// Calculate the sum of the data of the current nodes pointed by left and right pointers\nsum := right->data + left->data\n\n// If the sum is equal to k, add the pair to the answer vector\nif sum is equal to k:\nans.push_back(make_pair(left->data, right->data))\nleft := left->next\n\n// If the sum is greater than k, move the right pointer to the previous node\nelse if sum is greater than k:\nright := right->prev\n\n// If the sum is less than k, move the left pointer to the next node\nelse:\nleft := left->next\n\n// Return the vector containing pairs of nodes whose sum is equal to k\nreturn ans"
  },
  {
    "sign_no": 114,
    "question": "A doubly-linked list is a data structure that consists of sequentially linked nodes, and the nodes have reference to both the previous and the next nodes in the sequence of nodes.\n\n\nYou are given a sorted doubly linked list of size 'n'.\n\n\nRemove all the duplicate nodes present in the linked list.",
    "name": "Remove duplicates from sorted DLL",
    "topic": "ll",
    "level": "medium",
    "url": "https://bit.ly/3FtJUtZ",
    "approach": "to delete the duplicates ...in sorted DLL...we have to see for next node data..if its equal then we have to delete it..\nand while deleting the next node (dupllicate one) have to take care of prev link of todel node's next one.",
    "pseudo_code": "function removeDuplicates(head: Node*) -> Node*:\n// Initialize a temporary pointer to traverse the list\ntemp := head\n\n// Loop until the end of the list is reached\nwhile temp is not NULL:\n// Loop while there are consecutive nodes with the same data value\nwhile temp->next is not NULL and temp->data is equal to temp->next->data:\n// Store the node to be deleted\ntoDel := temp->next\n\n// Update the next pointer of the current node to skip the duplicate node\ntemp->next := toDel->next\n\n// If the next node exists, update its previous pointer\nif toDel->next is not NULL:\ntoDel->next->prev := temp\n\n// Delete the duplicate node\ndelete toDel\n\n// Move to the next node in the list\ntemp := temp->next\n\n// Return the head of the updated list\nreturn head"
  },
  {
    "sign_no": 115,
    "question": "You are given a linked list of 'n' nodes and an integer 'k', where 'k' is less than or equal to 'n'.\n\n\nYour task is to reverse the order of each group of 'k' consecutive nodes, if 'n' is not divisible by 'k', then the last group of nodes should remain unchanged.\n\n\nFor example, if the linked list is 1->2->3->4->5, and 'k' is 3, we have to reverse the first three elements, and leave the last two elements unchanged. Thus, the final linked list being 3->2->1->4->5.\n\n\nImplement a function that performs this reversal, and returns the head of the modified linked list.",
    "name": "Reverse LL in group of given size K",
    "topic": "ll",
    "level": "hard",
    "url": "https://leetcode.com/problems/reverse-nodes-in-k-group/",
    "approach": "given LL...reverse the parts with K nodes...\nso we know how to reverse the LL..we know how can we find the kth node..\nnow let temp to traverse the list and a prevNode so we can attach the reversed list next to previously reversed list.\nlet kthnode be the kthnode from temp...now store the nextnode of kthnode..so we can kthnode->null for reversal...\nnow the kthnode will be new node of reversed list...\nso now if temp was head then head is now kthnode...if not then prevNode->next is kthnode....now the temp is at the end of reversed list and we have to move the temp to next node and uipdate the prev node to temp before changing temp;",
    "pseudo_code": "function reverseList(head: Node*) -> Node*:\n// Base case: If the list is empty or has only one node, return the head\nif head is NULL or head->next is NULL:\nreturn head\n\n// Recursively reverse the sublist starting from the next node\nres := reverseList(head->next)\n\n// Adjust the pointers to reverse the current node with its successor\nhead->next->next := head\nhead->next := NULL\n\n// Return the new head of the reversed sublist\nreturn res\n\nfunction findKthNode(temp: Node*, k: int) -> Node*:\n// Decrease k by 1 to handle zero-based indexing\nk -= 1\n\n// Move the temp pointer k steps forward\nwhile temp is not NULL and k is not zero:\ntemp := temp->next\nk -= 1\n\n// Return the kth node or NULL if not found\nreturn temp\n\nfunction kReverse(head: Node*, k: int) -> Node*:\n// Initialize temp pointer to traverse the list and prevNode pointer to track the previous node\ntemp := head\nprevNode := NULL\n\n// Iterate through the list until temp becomes NULL\nwhile temp is not NULL:\n// Find the kth node from the current position\nkthNode := findKthNode(temp, k)\n\n// If the kth node is NULL, break the loop\nif kthNode is NULL:\nif prevNode is not NULL:\nprevNode->next := temp\nbreak\n\n// Store the next node after the kth node\nnextNode := kthNode->next\nkthNode->next := NULL\n\n// Reverse the sublist starting from the current position and update the head if necessary\nkthNode := reverseList(temp)\nif temp is equal to head:\nhead := kthNode\nelse:\nprevNode->next := kthNode\n\n// Update prevNode and move temp to the next node\nprevNode := temp\ntemp := nextNode\n\n// Return the head of the modified list\nreturn head"
  },
  {
    "sign_no": 116,
    "question": "You are given a linked list having ‘n’ nodes and an integer ‘k’.\n\n\nYou have to rotate the linked list to the right by ‘k’ positions .",
    "name": "Rotate a LL",
    "topic": "ll",
    "level": "medium",
    "url": "https://leetcode.com/problems/rotate-list/description/",
    "approach": "rotate k times..means our new head will be kth node from right...\nthat means we have to go to n-k-1 th node ..then our new head will be next of temp..\nand temp will be end of new list..now we have to link the end of prev list to prev head\nso temp2 at new head and traverse to end ...then temp2 next is head...hence now newhead will be our main head of the rotated LL.",
    "pseudo_code": "function findLength(head: Node*) -> int:\n// Initialize temp pointer to traverse the list and len to count nodes\ntemp := head\nlen := 0\n\n// Iterate through the list and count nodes until temp becomes NULL\nwhile temp is not NULL:\nlen := len + 1\ntemp := temp->next\n\n// Return the length of the list\nreturn len\n\nfunction rotate(head: Node*, k: int) -> Node*:\n// Find the length of the list\ncnt := findLength(head)\n\n// If k is a multiple of cnt or k is 0, no rotation is needed, return the head\nif k % cnt is equal to 0 or k is equal to 0:\nreturn head\n\n// Calculate the number of rotations needed\nres := cnt - (k % cnt) - 1\n\n// Initialize temp pointer to traverse the list\ntemp := head\n\n// Move temp to the node before the new head after rotation\nwhile res is not zero and temp is not NULL:\ntemp := temp->next\nres := res - 1\n\n// Store the new head after rotation\nnewHead := temp->next\n\n// Set the next pointer of the node before the new head to NULL\ntemp->next := NULL\n\n// Move temp2 to the last node of the original list\nNode* temp2 := newHead\nwhile temp2->next is not NULL:\ntemp2 := temp2->next\n\n// Connect the last node of the original list to the original head\ntemp2->next := head\n\n// Return the new head after rotation\nreturn newHead"
  },
  {
    "sign_no": 117,
    "question": "You are given a linked list containing 'n' 'head' nodes, where every node in the linked list contains two pointers:\n\n\n(1) ‘next’ which points to the next node in the list\n\n(2) ‘child’ pointer to a linked list where the current node is the head.\n\n\nEach of these child linked lists is in sorted order and connected by 'child' pointer.\n\n\nYour task is to flatten this linked such that all nodes appear in a single layer or level in a 'sorted order'.",
    "name": "Flattening of LL",
    "topic": "ll",
    "level": "hard",
    "url": "https://bit.ly/3w9TKf8",
    "approach": "we have to merge all the child list to single list in sorted order...\nto do that we can use merge sort method and merge function with some modification\nthe intuition is that we can merge two linked list in sorted order but there are multiper list...\nso we merge the last two list in one and return its head to last 3rd list...now we have the merged list and the 3rd list which can also be merged into one list...then again and again until we flatten the list/",
    "pseudo_code": "function merge(l1: Node*, l2: Node*) -> Node*:\n// Create a dummy node to hold the merged list\ndummyNode := new Node(-1)\n\n// Initialize the result pointer to the dummy node\nres := dummyNode\n\n// Iterate while both l1 and l2 are not NULL\nwhile l1 is not NULL and l2 is not NULL:\n// If the data in l1 is less than the data in l2\nif l1->data < l2->data:\n// Set the next pointer of the result node to l1\nres->child := l1\n// Move the result pointer to l1\nres := l1\n// Move l1 to its next node\nl1 := l1->child\n// Otherwise, the data in l2 is less than or equal to the data in l1\nelse:\n// Set the next pointer of the result node to l2\nres->child := l2\n// Move the result pointer to l2\nres := l2\n// Move l2 to its next node\nl2 := l2->child\n\n// Set the next pointer of the result node to NULL\nres->next := NULL\n\n// If l1 is not NULL, set the next pointer of the result node to l1\nif l1 is not NULL:\nres->child := l1\n// Otherwise, set the next pointer of the result node to l2\nelse:\nres->child := l2\n\n// Return the child of the dummy node, which holds the merged list\nreturn dummyNode->child\n\n\nfunction flattenLinkedList(head: Node*) -> Node*:\n// If head is NULL or head's next is NULL, return head\nif head is NULL or head's next is NULL:\nreturn head\n\n// Recursively flatten the remaining linked list starting from head's next\nmergedHead := flattenLinkedList(head->next)\n\n// Merge the current head with the flattened list starting from head's next\nhead := merge(head, mergedHead)\n\n// Return the flattened list\nreturn head"
  },
  {
    "sign_no": 118,
    "question": "You are given a linked list containing 'n' nodes, where every node in the linked list contains two pointers:\n\n\n(1) ‘next’ which points to the next node in the list\n\n(2) ‘random’ which points to a random node in the list or 'null'.\n\n\nYour task is to create a 'deep copy' of the given linked list and return its head.\n\n\nNote:\n\nA 'deep copy' of a linked list means we do not copy the references of the nodes of the original linked list, rather for each node in the original linked list, a new node is created.",
    "name": "Clone a Linked List with random and next pointer",
    "topic": "ll",
    "level": "hard",
    "url": "https://leetcode.com/problems/copy-list-with-random-pointer/",
    "approach": "we have to deep copy that means we have to connect next and random to the nodes that are not created yet and that what we have to solve here",
    "pseudo_code": ""
  },
  {
    "sign_no": 119,
    "question": "You are given a string ‘s’ of length 'n'.\n\n\nImplement the atoi(string s) function, which converts a given string into a 32-bit signed integer, following similar principles as the atoi function in C/C++.\n\n\nHere's the step-by-step algorithm for myAtoi(string s):\n\n\n1. Discard any leading whitespaces.\n\n\n2. If the next character (if not at the end of the string) is '-' or '+', consider it to determine the sign of the result. If neither is present, assume the result is positive.\n\n\n3. Read and accumulate digits until a non-digit character is encountered or the end of the input is reached.\n\n\n4. Convert the collected digits into an integer (e.g., \"123\" becomes 123, \"0032\" becomes 32). If no digits were read, the integer is 0. Adjust the sign as needed (as determined in step 2).\n\n\n5. If the integer falls outside the range of a 32-bit signed integer [-2^31, 2^31 - 1], constrain it to stay within the range. For instance, if the integer is less than -2^31, set it to -2^31; if it's greater than 2^31 - 1, set it to 2^31 - 1.\n\n\n6. Return the resulting integer.\n\n\nNote :\n\n1. Only the space character ' ' is treated as a whitespace.\n\n2. All characters other than leading whitespace or digits are considered.",
    "name": "Recursive Implementation of atoi()",
    "topic": "recursion",
    "level": "hard",
    "url": "https://leetcode.com/problems/string-to-integer-atoi/",
    "approach": "we have a string..contains leading spaces..sign...numbr....characters etc.\nso at start we iterate and skip the spaces..then take the sign and store it...\nfor next i we use recursion to store the number got from the string and check for conditions..\n\nthe base cases for the recursion will be \n1. if the number is negative and is less then int min the return intmin\n2. if number is positive and is greater then intmax then return int max\n3. if its not a number...it can either be alphabets or sign symbol but not digit character...then return the current ans.\n\nif not of above any three then we can add the current digit to our ans number and run the function for next index.\nsrote the returned ans to a var then return at the end.",
    "pseudo_code": "function helper(s: string, i: int, ans: long, sign: int) -> long:\n// Check if the product of sign and ans exceeds the integer limits\nif sign * ans <= INT_MIN:\nreturn INT_MIN\nif sign * ans >= INT_MAX:\nreturn INT_MAX\n\n// Base case: if the index exceeds the string size or the current character is not a digit\nif i >= s.size() or s[i] < '0' or s[i] > '9':\nreturn sign * ans\n\n// Recursively calculate the result\nans = helper(s, i+1, (ans * 10 + (s[i] - '0')), sign)\n\n// Return the final result\nreturn ans\n\nfunction createAtoi(s: string) -> int:\n// Initialize variables: i for iteration, sign for sign detection, n for string size\ni := 0\nsign := 1\nn := s.size()\n\n// Skip leading spaces\nwhile i < n and s[i] == ' ':\ni++\n\n// Check for sign\nif s[i] == '-' or s[i] == '+':\nsign := -1 if s[i] == '-' else 1\ni++\n\n// Call the helper function to process the string and convert it to an integer\nreturn helper(s, i, 0, sign)"
  },
  {
    "sign_no": 120,
    "question": "You are given two numbers ’x’(it’s a float), and ’n’(it’s a integer).\n\n\nYour task is to calculate ‘x’ raised to power ‘n’, and return it.\n\n\nThe expected time complexity is ’O(logn)’, and the expected space complexity is ’O(1)’, where ‘n’ is the power to which the number should be raised.\n\n\nNote:\n\nIn the output, you will see the number returned by you upto 6 decimal places.",
    "name": "Pow(x, n)",
    "topic": "recursion",
    "level": "medium",
    "url": "https://leetcode.com/problems/powx-n/",
    "approach": "it uses the math properties of power..\nas let 4^5 = 4 * 4^4 = 4 * 8 ^ 2\n\nso we can divide the problem according to n if its odd or even...",
    "pseudo_code": "function myPow(x: float, n: int) -> float:\n// Base case: if n is 0, return 1\nif n == 0:\nreturn 1.0\n\n// If n is negative, adjust x and n accordingly\nif n < 0:\nn := -n\nx := 1.0 / x\n\n// Recursive cases based on the parity of n\nif n is odd:\nreturn x * myPow(x, n-1)\nelse:\nreturn myPow(x * x, n / 2)"
  },
  {
    "sign_no": 121,
    "question": "A number is called good if it's every digit (except the rightmost digit) is larger than the sum of digits on the right side of that digit.\n\n\nFind all the good numbers in the range from 'a' to 'b' (both inclusive), such that none of them contains 'digit' as a digit.",
    "name": "Count Good numbers",
    "topic": "recursion",
    "level": "easy",
    "url": "https://leetcode.com/problems/count-good-numbers/",
    "approach": "so we have the range....\nwe can loop to the range(inclusive) and for each number we can check wheather its a good or not\nto check we can use recursion..let n be the number...then base case will be if n == 0 return true;\nif any time the las t digit is less then sum of prev digits then its not a good number so return false\nif last dig is greater then sum and its nor equal to given digit then we can add the digit to sum and go for next digit...n/10 for n.",
    "pseudo_code": "function isGood(n: int, digit: int, sum: int) -> bool:\n// Base case\nif n == 0:\nreturn true\n\n// Extract the last digit\nlast := n % 10\n\n// Check if the last digit is greater than sum and not equal to the given digit\nif last > sum and last != digit:\n// Update sum and recursively check the remaining digits\nsum := sum + last\nreturn isGood(n / 10, digit, sum)\nelse:\nreturn false\n\nfunction goodNumbers(a: int, b: int, digit: int) -> vector<int>:\n// Initialize an empty vector to store the good numbers\nans := []\n\n// Iterate through the range [a, b]\nfor i from a to b:\n// Skip numbers ending with the given digit\nif i % 10 == digit:\ncontinue\n\n// Check if the number is good based on the helper function isGood\nif isGood(i / 10, digit, i % 10):\n// If the number is good, add it to the answer vector\nans.push_back(i)\n\n// Return the vector containing good numbers\nreturn ans"
  },
  {
    "sign_no": 122,
    "question": "You are given a stack ‘S’. Your task is to sort the sack recursively.\n\n\nNote:\n\nLooping through the stack is not allowed.\nYou need to return a stack that is sorted in descending order.",
    "name": "Sort a stack using recursion",
    "topic": "recursion",
    "level": "medium",
    "url": "https://bit.ly/3Pu0YBn",
    "approach": "sort the stack using recursion only...\nso we can go to the last of stack and then put each element at correct position...\nso we have to use recursioin to reach that value then again use a different recursion to put it at correct position.",
    "pseudo_code": "function putAtCorrect(s: stack<int>, val: int) -> void:\nif s is empty or s.top() <= val:\n// If the stack is empty or the top element is less than or equal to the value,\n// push the value onto the stack\ns.push(val)\nelse:\n// Otherwise, recursively pop elements from the stack until the correct position is found\ntemp := s.top()\ns.pop()\nputAtCorrect(s, val)\ns.push(temp)\n\nfunction sortStack(s: stack<int>) -> stack<int>:\n// Base case: If the stack is empty or contains only one element, return the stack as it is\nif s is empty or s.size() == 1:\nreturn s\n\n// Recursive case: Sort the stack using merge sort\ntemp := s.top()\ns.pop()\nsortStack(s) // Recursively sort the remaining elements\n\n// Put the top element at the correct position in the sorted stack\nputAtCorrect(s, temp)\n\n// Return the sorted stack\nreturn s"
  },
  {
    "sign_no": 123,
    "question": "Reverse a given stack of 'N' integers using recursion. You are required to make changes in the input parameter itself.\n\n\nNote: You are not allowed to use any extra space other than the internal stack space used due to recursion.",
    "name": "Reverse a stack using recursion",
    "topic": "recursion",
    "level": "easy",
    "url": "https://bit.ly/3podAiY",
    "approach": "similer to prev one...\nthis time we don't have to put it at correct position instead we have to put it at the bottom of stack...",
    "pseudo_code": "function insertAtBottom(st: stack<int>, val: int) -> void:\nif st is empty:\n// If the stack is empty, push the value onto the stack\nst.push(val)\nreturn\nelse:\n// Otherwise, recursively pop elements from the stack until it's empty,\n// then push the value onto the stack\ntemp := st.top()\nst.pop()\ninsertAtBottom(st, val)\nst.push(temp)\n\nfunction reverseStack(stack: stack<int>) -> void:\n// Base case: If the stack is empty or contains only one element, return\nif stack is empty or stack.size() == 1:\nreturn\n\n// Recursive case: Reverse the stack using recursion\ntemp := stack.top()\nstack.pop()\nreverseStack(stack) // Recursively reverse the remaining elements of the stack\n\n// Insert the top element at the bottom of the reversed stack\ninsertAtBottom(stack, temp)"
  },
  {
    "sign_no": 124,
    "question": "You have been given an integer 'N'. Your task is to generate and return all binary strings of length 'N' such that there are no consecutive 1's in the string.\n\n\nA binary string is that string which contains only ‘0’ and ‘1’.",
    "name": "Generate all binary strings",
    "topic": "recursion",
    "level": "medium",
    "url": "https://bit.ly/3QJ0vwc",
    "approach": "to solve this problem using recursion...\nwe can see there should not be any consecutive ones...\nso we have different choces according to our last element..\nif last element is 1 then we can only put 0\nif last element is 0 then we can either select 0 or 1 (back tracking)",
    "pseudo_code": "function helper(n: int, s: string, ans: vector<string>) -> void:\n// Base case: If n becomes 0, add the generated string to the answer vector\nif n == 0:\nans.push_back(s)\nreturn\n\n// Recursive case:\n// If the last character of the string is '1', add '0' to the string and recursively call helper\nif last character of s is '1':\ntemp := s + '0'\nhelper(n - 1, temp, ans)\n\n// If the last character of the string is '0', recursively call helper twice\nelse:\ntemp1 := s + '0'\nhelper(n - 1, temp1, ans)\n\ntemp2 := s + '1'\nhelper(n - 1, temp2, ans)\n\nfunction generateString(N: int) -> vector<string>:\n// Initialize an empty vector to store the generated strings\nans: vector<string>\n\n// Call the helper function to generate strings recursively\nhelper(N, \"\", ans)\n\n// Return the vector containing the generated strings\nreturn ans"
  },
  {
    "sign_no": 125,
    "question": "You are given an integer 'N', your task is to generate all combinations of well-formed parenthesis having ‘N’ pairs.\n\n\nA parenthesis is called well-formed if it is balanced i.e. each left parenthesis has a matching right parenthesis and the matched pairs are well nested.",
    "name": "Generate Paranthesis",
    "topic": "recursion",
    "level": "medium",
    "url": "https://leetcode.com/problems/generate-parentheses/",
    "approach": "we can either put the open and close bracket if they fulfil some condition at a given point..\nso to solve this using recursion we will track the number of open and close brackets used \nso base case will be if open == n and close == n then we got our 1 string...so return to prev \n\nif open < n then we can put open brac \nif close < open then we can put clsoe brac",
    "pseudo_code": "function helper(n: int, s: string, ans: vector<string>, open: int, close: int) -> void:\n// Base case: If the number of open and close parentheses reaches n, add the generated string to the answer vector\nif open == n and close == n:\nans.push_back(s)\nreturn\n\n// Recursive case:\n// If the number of open parentheses is less than n, add an open parenthesis and recursively call helper\nif open < n:\ntemp1 := s + '('\nhelper(n, temp1, ans, open + 1, close)\n\n// If the number of close parentheses is less than open parentheses, add a close parenthesis and recursively call helper\nif close < open:\ntemp2 := s + ')'\nhelper(n, temp2, ans, open, close + 1)\n\nfunction validParenthesis(n: int) -> vector<string>:\n// Initialize an empty vector to store the valid parentheses strings\nans: vector<string>\n\n// Call the helper function to generate valid parentheses strings recursively\nhelper(n, \"\", ans, 0, 0)\n\n// Return the vector containing the valid parentheses strings\nreturn ans"
  },
  {
    "sign_no": 126,
    "question": "Given a string 'S' of length 'N', return all the subsequences of the given string.\n\n\nA subsequence is a sequence that can be derived from the given sequence by deleting zero or more elements without changing the order of the remaining elements.\n\n\nNote :\n\nYou may return the subsequences in any order but they will be printed in lexicographically ascending order.\n\nIf a string from the returned array has a length of zero, it will be represented as 'Empty String' in the output.",
    "name": "Print all subsequences/Power Set",
    "topic": "recursion",
    "level": "medium",
    "url": "https://leetcode.com/problems/subsets/",
    "approach": "inorder to find all subsequence we can use recursion ..\nthe base case will be the index == s.size() then we can push the current string to our ans string..\nand each time we have two choices...either choose the current character or not to choose...\nusing backtracking we can get all the possible subsequences possible.",
    "pseudo_code": "function helper(s: string, i: int, temp: string, ans: vector<string>) -> void:\n// Base case: If the index i reaches the end of string s, add the generated subsequence to the answer vector\nif i == s.size():\nans.push_back(temp)\nreturn\n\n// Include the current character at index i in the subsequence and recursively call helper with i+1\ntemp.push_back(s[i])\nhelper(s, i + 1, temp, ans)\n\n// Exclude the current character at index i in the subsequence and recursively call helper with i+1\ntemp.pop_back()\nhelper(s, i + 1, temp, ans)\n\nfunction generateSubsequences(s: string) -> vector<string>:\n// Initialize an empty vector to store the generated subsequences\nans: vector<string>\n\n// Call the helper function to generate subsequences recursively\nhelper(s, 0, \"\", ans)\n\n// Return the vector containing the generated subsequences\nreturn ans"
  },
  {
    "sign_no": 127,
    "question": "You are given two strings 'A' and 'B' of length 'N' and 'M' respectively.\n\n\nReturn the string that has more distinct subsequences, if both strings have the same number of distinct subsequences, then return 'A'.",
    "name": "Learn All Patterns of Subsequences (Theory)",
    "topic": "recursion",
    "level": "medium",
    "url": "https://bit.ly/3US225G",
    "approach": "so we have two strings..with duplilcates present in it..but we have to find out the number of distnict subsequences..\n\nso there is one way we can find all the subsequences and eliminate the duplicates using the set..but it will show TLE..\nhowever ..we can sort both the strings..then while choosing to pick or not we can eliminate the duplicates...\nto reduce the time complexity....",
    "pseudo_code": "function solve(a: string, index: int, n: int, cnt: int) -> void:\n// Base case: If the index reaches the end of string a, increment the count and return\nif index == n:\ncnt++\nreturn\n\n// Recursively call solve with the next index\nsolve(a, index + 1, n, cnt)\n\n// Skip consecutive identical characters\nwhile index + 1 < n and a[index] == a[index + 1]:\nindex++\n\n// Recursively call solve with the next index\nsolve(a, index + 1, n, cnt)\n\nfunction moreSubsequence(n: int, m: int, a: string, b: string) -> string:\n// Create copies of strings a and b\nstring a1 = a, b1 = b\n\n// Sort strings a and b\nsort(a.begin(), a.end())\nsort(b.begin(), b.end())\n\n// Initialize counts for subsequences of strings a and b\nint cnt1 = 0, cnt2 = 0\n\n// Calculate the number of distinct subsequences for strings a and b\nsolve(a, 0, n, cnt1)\nsolve(b, 0, m, cnt2)\n\n// Return the original string with the larger number of distinct subsequences\nreturn cnt1 >= cnt2 ? a1 : b1"
  },
  {
    "sign_no": 128,
    "question": "You are given an array 'A' of size 'N' and an integer'K'’. You need to generate and return all subarrays of array ‘A’ whose sum = ‘K’.\n\n\nNote: In the output, you will see the 2D array lexicographically sorted.",
    "name": "Count all subsequences with sum K",
    "topic": "recursion",
    "level": "hard",
    "url": "https://bit.ly/3SVf1me",
    "approach": "we can solve this problem using two pointer...as all values is positive to the sum will never go down \nso using sliding window we can get the window where sum is equal to target then we can put that window to ans vector..",
    "pseudo_code": "function subarraysWithSumK(a: vector<int>, k: long long) -> vector<vector<int>>:\nn = size(a)\nleft = 0\nright = 0\nsum = 0\nans = []\n\nwhile right < n:\nsum += a[right]\nright++\n\nwhile sum > k:\nsum -= a[left]\nleft++\n\nif sum == k:\ntemp = []\nfor i from left to right-1:\ntemp.push_back(a[i])\nans.push_back(temp)\n\nreturn ans"
  },
  {
    "sign_no": 129,
    "question": "You are given an array 'A' of 'N' integers. You have to return true if there exists a subset of elements of 'A' that sums up to 'K'. Otherwise, return false.",
    "name": "Check if there exists a subsequence with sum K",
    "topic": "recursion",
    "level": "medium",
    "url": "https://www.codingninjas.com/studio/problems/subset-sum_630213?utm_source=striver&utm_medium=website&utm_campaign=a_zcoursetuf",
    "approach": "to check if there exists a subset with sum k..we can use recursion to generate subsets and store there sum..\nif sum is k then its true...\n\nbase case will be..if sum > k then there is no need to check further...so return false to prev calls...\nand if i == n then if sum == k return true..else return false;;...\n\nwe can either choose to pick or not to pick an element. (backtracking) the sum...\nif at an given element if both picking and not picking gives false result then we return false at end.",
    "pseudo_code": "function helper(i: int, n: int, k: int, a: vector<int>, sum: int) -> bool:\nif sum > k:\nreturn false\n\nif i == n:\nif sum == k:\nreturn true\nreturn false\n\nsum += a[i]\nif helper(i+1, n, k, a, sum):\nreturn true\n\nsum -= a[i]\nif helper(i+1, n, k, a, sum):\nreturn true\n\nreturn false\n\nfunction isSubsetPresent(n: int, k: int, a: vector<int>) -> bool:\nreturn helper(0, n, k, a, 0)"
  },
  {
    "sign_no": 130,
    "question": "You are given an array 'ARR' of 'N' distinct positive integers. You are also given a non-negative integer 'B'.\n\n\nYour task is to return all unique combinations in the array whose sum equals 'B'. A number can be chosen any number of times from the array 'ARR'.\n\n\nElements in each combination must be in non-decreasing order.",
    "name": "Combination Sum",
    "topic": "recursion",
    "level": "medium",
    "url": "https://leetcode.com/problems/combination-sum/",
    "approach": "given we have to return the cmbination in sorted order so we sort the given array first so when we choose the subsequence we get get the combinatin in sorted order...\nbase cases -> \n1. sum > k\n2. sum == k\n3. i == n\n\nnow we can use backtracking to either choose to pick or not to pick the element.",
    "pseudo_code": "function helper(i: int, sum: int, target: int, arr: vector<int>, temp: vector<int>, ans: vector<vector<int>>) -> void:\nif sum > target:\nreturn\nif sum == target:\nans.push_back(temp)\nreturn\nif i == arr.size():\nreturn\n\ntemp.push_back(arr[i])\nsum += arr[i]\nhelper(i, sum, target, arr, temp, ans)\n\nsum -= arr[i]\ntemp.pop_back()\nhelper(i + 1, sum, target, arr, temp, ans)\n\nfunction combSum(arr: vector<int>, B: int) -> vector<vector<int>>:\nsort(arr.begin(), arr.end())\nans: vector<vector<int>> = []\nhelper(0, 0, B, arr, [], ans)\nreturn ans"
  },
  {
    "sign_no": 131,
    "question": "You are given an array ‘arr’ of ‘n’ positive integers.\n\n\nYou are also given a positive integer ‘target’.\n\n\nYour task is to find all unique combinations of elements of array ‘arr’ whose sum is equal to ‘target’. Each number in ‘arr’ may only be used once in the combination.\n\n\nElements in each combination must be in non-decreasing order and you need to print all unique combinations in lexicographical order.\n\n\nNote:\n\nIn lexicographical order, combination/array ‘a’ comes before array ‘b’ if at the first index 'i' where 'a[i]' differs from 'b[i]', 'a[i]' < 'b[i] or length of 'a' is less than 'b'.",
    "name": "Combination Sum-II",
    "topic": "recursion",
    "level": "medium",
    "url": "https://leetcode.com/problems/combination-sum-ii/",
    "approach": "Similer to prev one...\nwith some condition that the given array contains duplicates so we have to take care of them inorder to get all the unique subsets in sorted order...",
    "pseudo_code": "function helper(i: int, n: int, target: int, arr: vector<int>, temp: vector<int>, ans: vector<vector<int>>) -> void:\nif i == arr.size():\nif target == 0:\nans.push_back(temp)\nreturn\n\nif arr[i] <= target:\ntemp.push_back(arr[i])\nhelper(i + 1, n, target - arr[i], arr, temp, ans)\ntemp.pop_back()\n\nwhile i + 1 < arr.size() and arr[i] == arr[i + 1]:\ni++\nhelper(i + 1, n, target, arr, temp, ans)\n\nfunction combinationSum2(arr: vector<int>, n: int, target: int) -> vector<vector<int>>:\nsort(arr.begin(), arr.end())\nans: vector<vector<int>> = []\ntemp: vector<int> = []\nhelper(0, n, target, arr, temp, ans)\nreturn ans"
  },
  {
    "sign_no": 132,
    "question": "You are given an array 'nums' of ‘n’ integers.\n\n\nReturn all subset sums of 'nums' in a non-decreasing order.\n\n\nNote:\n\nHere subset sum means sum of all elements of a subset of 'nums'. A subset of 'nums' is an array formed by removing some (possibly zero or all) elements of 'nums'.",
    "name": "Subset Sum-I",
    "topic": "recursion",
    "level": "medium",
    "url": "https://bit.ly/3C9GQRS",
    "approach": "similer to prev ones...\nwe can either choose the element or not...\nand add that element to sum or remove or backtracking.\n\nwhen i == n then its the base case.",
    "pseudo_code": "function helper(i: int, sum: int, num: vector<int>, ans: vector<int>) -> void:\nif i == num.size():\nans.push_back(sum)\nreturn\n\nsum += num[i]\nhelper(i + 1, sum, num, ans)\n\nsum -= num[i]\nhelper(i + 1, sum, num, ans)\n\nfunction subsetSum(num: vector<int>) -> vector<int>:\nans: vector<int> = []\nhelper(0, 0, num, ans)\nsort(ans.begin(), ans.end())\nreturn ans"
  },
  {
    "sign_no": 133,
    "question": "You are given an sorted integer array of size 'n'.\n\n\nYour task is to find and return all the unique subsets of the input array.\n\n\nSubsets are arrays of length varying from 0 to 'n', that contain elements of the array. But the order of elements should remain the same as in the input array.\n\n\nNote:\n\nThe order of subsets is not important. You can return the subsets in any order. However, in the output, you will see the subsets in lexicographically sorted order",
    "name": "Subset Sum-II",
    "topic": "recursion",
    "level": "medium",
    "url": "https://leetcode.com/problems/subsets-ii/",
    "approach": "given the array is sorted and contains dplicate elements...\nso we have to take care of the duplicates and and generate all the unique subsets...",
    "pseudo_code": "function helper(i: int, arr: vector<int>, temp: vector<int>, ans: vector<vector<int>>) -> void:\nif i == arr.size():\nans.push_back(temp)\nreturn\n\ntemp.push_back(arr[i])\nhelper(i + 1, arr, temp, ans)\n\nwhile i < arr.size() - 1 and arr[i] == arr[i + 1]:\ni++\n\ntemp.pop_back()\nhelper(i + 1, arr, temp, ans)\n\nfunction getUniqueSubsets(arr: vector<int>) -> vector<vector<int>>:\ntemp: vector<int> = []\nans: vector<vector<int>> = []\nhelper(0, arr, temp, ans)\nreturn ans"
  },
  {
    "sign_no": 134,
    "question": "You are given ‘k’ and ‘n’ and you have to do the following:-\n\n\nReturn all possible combinations of arrays whose elements sum is equal to ‘n’, and you can use only elements in the range '1' to '9' inclusive, and you can use each element at most once, and the size of the combination should be exactly ‘k’.\n\n\nIf there is no combination, return an empty array.\n\n\nIt should be noted that the 2-D array should be returned in sorted order, meaning the lexicographically smaller array should come first.\n\n\nAlso, at each index of the 2-D array, the elements present in the array present at that index should be in sorted order.\n\n\nNote:\n\nTwo combinations are called different if an element is in one combination and not in another. \n\nAlso, in the output, you will see the 2-D array returned by you.",
    "name": "Combination Sum - III",
    "topic": "recursion",
    "level": "hard",
    "url": "https://leetcode.com/problems/combination-sum-iii/",
    "approach": "combinatino of prev problems...\nhave to pick k length subset from 1 to 9 digits..1 digit can only be use once\nwe can either pick or not pick the element..\nthere will be some more base cases inorder to have exact k length subset having sum = target.\n\nso if sum > target or temp.size > k return;\nif sum == target then check for size...and if size is equal to k then its is one of our ans...if not then return;\nalso if i == n....then we are at the end of our array so return;\n\nthen similer to prev problems...we can use backtracking to pick or not to pick a element in our subset.",
    "pseudo_code": "function helper(i: int, k: int, n: int, sum: int, arr: vector<int>, temp: vector<int>, ans: vector<vector<int>>) -> void:\nif sum > n or temp.size() > k:\nreturn\n\nif sum == n:\nif temp.size() == k:\nans.push_back(temp)\nreturn\n\nif i == arr.size():\nreturn\n\ntemp.push_back(arr[i])\nsum += arr[i]\nhelper(i + 1, k, n, sum, arr, temp, ans)\n\nsum -= arr[i]\ntemp.pop_back()\nhelper(i + 1, k, n, sum, arr, temp, ans)\n\nfunction combinationSum(k: int, n: int) -> vector<vector<int>>:\narr: vector<int> = {1, 2, 3, 4, 5, 6, 7, 8, 9}\nans: vector<vector<int>> = []\nhelper(0, k, n, 0, arr, [], ans)\nreturn ans"
  },
  {
    "sign_no": 135,
    "question": "Given a digit string 's', return all possible letter combinations that the number could represent.\n\n\nA mapping of digits to letters (just like on the telephone buttons) is given below.\n\nNote:\n\nYou don’t need to print anything. Just implement the given function.",
    "name": "Letter Combinations of a Phone number",
    "topic": "recursion",
    "level": "medium",
    "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/",
    "approach": "",
    "pseudo_code": ""
  },
  {
    "sign_no": 136,
    "question": "Given a string 's', partition s such that every partition string is a palindrome.\n\n\nReturn all possible palindrome partitioning of s.\n\n\nNote:\n\nYou don’t need to print anything. Just implement the given function.",
    "name": "Palindrome Partitioning",
    "topic": "recursion",
    "level": "medium",
    "url": "https://leetcode.com/problems/palindrome-partitioning/",
    "approach": "given string...we have to create partitionsuch that the string before partition is palindrom..then we can use recursive function to solve the remaining string for partition..then we can get back using backtracking for another possiblity of partition..\nbase case : \nif i == s.size() then push the temp string array to ans and return...\n\nnow we can check for a substring that is palindrome...using a loop from index to s.size();\nif we find a string that is palindrome then we can push it to temp array and call the function for iter + 1,\nthen pop back...that pushed string from temp for backtracking.",
    "pseudo_code": "function isPalindrome(s: string, start: int, end: int) -> bool:\nwhile start <= end:\nif s[start++] != s[end--]:\nreturn false\nreturn true\n\nfunction helper(index: int, s: string, temp: vector<string>, ans: vector<vector<string>>) -> void:\nif index == s.size():\nans.push_back(temp)\nreturn\n\nfor i from index to s.size() - 1:\nif isPalindrome(s, index, i):\ntemp.push_back(s.substr(index, i - index + 1))\nhelper(i + 1, s, temp, ans)\ntemp.pop_back()\n\nfunction partition(s: string) -> vector<vector<string>>:\nans: vector<vector<string>> = []\ntemp: vector<string> = []\n\nhelper(0, s, temp, ans)\nreturn ans"
  },
  {
    "sign_no": 137,
    "question": "You are given a 2D board('N' rows and 'M' columns) of characters and a string 'word'.\n\n\nYour task is to return true if the given word exists in the grid, else return false. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring.\n\n\nNote:\n\nThe same letter cell should not be used more than once.",
    "name": "Word Search",
    "topic": "recursion",
    "level": "medium",
    "url": "https://leetcode.com/problems/word-search/",
    "approach": "given board of n*m dimensions and we have to find the word...\nso first we start by finding the 1st character of word..then from that character indexes..\nrow, col we can start search for next characters using recursion...\nbase case wil be...\n1. index == word.size() then we find the word....\n2. row and col out of bounds..., the current char is '!' or the current char is not equal to word's character then return false..\nif not above cases that means we found the char we are looking for now we can search for next char of word.\nso we first store the current char to temp then assign it as '!' so if we visit it again we know we can't visit again...\nthen we can go for top bottom right and left and any of them return's true that means we found the word.",
    "pseudo_code": "function exist(index: int, row: int, col: int, word: string, board: vector<vector<char>>, n: int, m: int) -> bool:\nif index == word.size():\nreturn true\nif row < 0 or col < 0 or row == n or col == m or board[row][col] != word[index] or board[row][col] == '!':\nreturn false\n\nlet c = board[row][col]\nboard[row][col] = '!'\n\nlet top = exist(index + 1, row - 1, col, word, board, n, m)\nlet bottom = exist(index + 1, row + 1, col, word, board, n, m)\nlet right = exist(index + 1, row, col + 1, word, board, n, m)\nlet left = exist(index + 1, row, col - 1, word, board, n, m)\n\nboard[row][col] = c\nreturn top or bottom or right or left\n\nfunction present(board: vector<vector<char>>, word: string, n: int, m: int) -> bool:\nlet index = 0\nfor i from 0 to n - 1:\nfor j from 0 to m - 1:\nif board[i][j] == word[index]:\nif exist(index, i, j, word, board, n, m):\nreturn true\nreturn false"
  },
  {
    "sign_no": 138,
    "question": "You are given 'N', and for a given 'N x N' chessboard. Find a configuration of 'N' queens such that no queen can attack any other queen on the chess board.\n\n\nA queen can be killed when it lies in the same row, or same column, or the same diagonal of any of the other queens. You have to return all such configurations.\n\n\nNote:\n\nIf no such configuration is present return an empty array, it will be represented as 'No Configuration' in the output.",
    "name": "N Queen",
    "topic": "recursion",
    "level": "hard",
    "url": "https://leetcode.com/problems/n-queens/",
    "approach": "given n. we have to put queens such that they don't attack each other...\nso we can check for each column and put the queen in that column ...so we dont have to check on right as we are putting the queen column wise and no queen will be place at right of our current col..\nso if we can;t put the queen in current colulmn that means we have to change the putting of our previous queens...\nusing backtracknig we can do this.",
    "pseudo_code": "function putInAns(ans: vector<vector<int>>, board: vector<vector<int>>, n: int):\ntemp: vector<int>\nfor i from 0 to n - 1:\nfor j from 0 to n - 1:\ntemp.push_back(board[i][j])\nans.push_back(temp)\n\nfunction canPlace(row: int, col: int, board: vector<vector<int>>, n: int) -> bool:\ndumRow: int = row\ndumCol: int = col\n\nwhile row >= 0 and col >= 0:\nif board[row--][col--] == 1:\nreturn false\nrow = dumRow\ncol = dumCol\nwhile col >= 0:\nif board[row][col--] == 1:\nreturn false\ncol = dumCol\nwhile row < n and col >= 0:\nif board[row++][col--] == 1:\nreturn false\nreturn true\n\nfunction helper(col: int, n: int, ans: vector<vector<int>>, board: vector<vector<int>>):\nif col == n:\nputInAns(ans, board, n)\nreturn\n\nfor i from 0 to n - 1:\nif canPlace(i, col, board, n):\nboard[i][col] = 1\nhelper(col + 1, n, ans, board)\nboard[i][col] = 0\n\nfunction nQueens(n: int) -> vector<vector<int>>:\nans: vector<vector<int>>\nboard: vector<vector<int>> = create a 2D vector of size n x n filled with 0\n\nhelper(0, n, ans, board)\nreturn ans"
  },
  {
    "sign_no": 139,
    "question": "You are given a N*N maze with a rat placed at 'mat[0][0]'. Find all paths that rat can follow to reach its destination i.e. mat[N-1][N-1]. The directions in which the rat can move are 'U'(up), 'D'(down), 'L' (left), 'R' (right).\n\n\nIn the given maze, each cell can have a value of either 0 or 1. Cells with a value of 0 are considered blocked, which means the rat cannot enter or traverse through them. On the other hand, cells with a value of 1 are open, indicating that the rat is allowed to enter and move through those cells.",
    "name": "Rat in a Maze",
    "topic": "recursion",
    "level": "hard",
    "url": "https://practice.geeksforgeeks.org/problems/rat-in-a-maze-problem/1",
    "approach": "similer to word probelm...we have to look for top bottom right left and can't go on the same block again...\nso we first check if the rat can be at row , col or not...so we check for bounds of row and col and also char at row, col is not 0,\n\nthen we can change the current char to 0 so while traversing on all direction we don;t want to get back to this ..\nso using backtracknig we can recursively go to all direction and at the end we can put our char back to 1.",
    "pseudo_code": "function helper(i: int, j: int, temp: string, ans: vector<string>, mat: vector<vector<int>>, n: int, m: int):\nif i < 0 or i == n or j < 0 or j == n or mat[i][j] == 0:\nreturn\nif i == n - 1 and j == m - 1:\nans.push_back(temp)\nreturn\n\nmat[i][j] = 0\n// Move right\ntemp.push_back('R')\nhelper(i, j + 1, temp, ans, mat, n, m)\ntemp.pop_back()\n\n// Move down\ntemp.push_back('D')\nhelper(i + 1, j, temp, ans, mat, n, m)\ntemp.pop_back()\n\n// Move left\ntemp.push_back('L')\nhelper(i, j - 1, temp, ans, mat, n, m)\ntemp.pop_back()\n\n// Move up\ntemp.push_back('U')\nhelper(i - 1, j, temp, ans, mat, n, m)\ntemp.pop_back()\n\nmat[i][j] = 1\n\nfunction ratMaze(mat: vector<vector<int>>) -> vector<string>:\nn: int = get the number of rows of mat\nm: int = get the number of columns of mat\nans: vector<string>\ntemp: string\n\nhelper(0, 0, temp, ans, mat, n, m)\nreturn ans"
  },
  {
    "sign_no": 140,
    "question": "You are given a string 's', and a dictionary of words 'dict' containing 'n' words. Your task is to add spaces in 's' to form valid sentences, where each word is a word from the dictionary.\n\n\nYou need to return all possible sentences that can be formed using the given dictionary.\n\n\nNote :\n\nThe same word from a dictionary can be used as many times as possible to make sentences.",
    "name": "Word Break",
    "topic": "recursion",
    "level": "medium",
    "url": "https://leetcode.com/problems/word-break/",
    "approach": "similer to palindrome partition problem (136)\nwe can make a map of given words present in dictionary so we can get them in o(1) TC.\nno we can recursively solve the problem making it smaller every time..\nwe can take a substring from index to i which is present in the dictionary then we can add it to our temp then call the function for next part of the give string.",
    "pseudo_code": "Function getAllValidSentences(s, dict):\nCreate an empty unordered_map dict_map\n\nFor each word in dict:\nIncrement the frequency of the word in dict_map\n\nCreate an empty list ans\n\nCall helper(0, s, dict_map, ans, \"\")\n\nReturn ans\n\nFunction helper(index, s, mpp, ans, temp):\nIf index is equal to the length of s:\nAdd temp to ans (a valid sentence has been constructed)\nReturn\n\nFor i from index to the length of s:\nExtract the substring from s starting at index and ending at i (inclusive), let's call it part\nIf part exists in mpp:\nCreate a new string newTemp by appending part to temp (separated by a space)\nCall helper(i + 1, s, mpp, ans, newTemp)"
  },
  {
    "sign_no": 141,
    "question": "You are given an undirected graph as an adjacency matrix consisting of 'v' vertices and an integer 'm'.\n\n\nYou need to return 'YES' if you can color the graph using at most 'm' colors so that no two adjacent vertices are the same. Else, return 'NO'.",
    "name": "M Coloring Problem",
    "topic": "recursion",
    "level": "hard",
    "url": "https://practice.geeksforgeeks.org/problems/m-coloring-problem-1587115620/1#",
    "approach": "",
    "pseudo_code": ""
  },
  {
    "sign_no": 142,
    "question": "You are given a 9*9 sudoku board, in which some entries are filled and others are 0 (0 indicates the cell is empty).\n\n\nYou must return true if the Sudoku puzzle can be solved, else return false.",
    "name": "Sudoko Solver",
    "topic": "recursion",
    "level": "hard",
    "url": "https://leetcode.com/problems/sudoku-solver/",
    "approach": "firat we can find the empty cell..then for that cell we have to find a value that can be putted there...\nbetween 1 to 9..so put the value..then recursively call the function again for next empty cells,\nif the value we putted solves the sudoku then we can return true, \nelse we have to backtrack to find another value for that position.",
    "pseudo_code": "Function isValid(row, col, num, board)\nInput: row - the row index\ncol - the column index\nnum - the number to be validated\nboard - the Sudoku board\n\nOutput: true if num is valid in the given position, false otherwise\n\nFor i from 0 to 8:\nIf board[row][i] is equal to num\nReturn false\nIf board[i][col] is equal to num\nReturn false\nIf board[3 * (row / 3) + (i / 3)][3 * (col / 3) + (i % 3)] is equal to num\nReturn false\n\nReturn true\nEnd Function\n\nFunction solve(board)\nInput: board - the Sudoku board to be solved\n\nOutput: true if the board is solvable, false otherwise\n\nFor i from 0 to 8:\nFor j from 0 to 8:\nIf board[i][j] is equal to 0\nFor k from 1 to 9:\nIf isValid(i, j, k, board)\nSet board[i][j] to k\nIf solve(board) is true\nReturn true\nSet board[i][j] to 0\nReturn false\n\nReturn true\nEnd Function\n\nFunction sudokuSolver(board)\nInput: board - the Sudoku board to be solved\n\nOutput: true if the Sudoku puzzle is solvable, false otherwise\n\nIf solve(board) is true\nReturn true\nElse\nReturn false\nEnd Function"
  },
  {
    "sign_no": 143,
    "question": "Given a string num that contains only digits and an integer target, return all possibilities to insert the binary operators '+', '-', and/or '*' between the digits of num so that the resultant expression evaluates to the target value.\n\nNote that operands in the returned expressions should not contain leading zeros.",
    "name": "Expression Add Operators",
    "topic": "recursion",
    "level": "hard",
    "url": "https://leetcode.com/problems/expression-add-operators/",
    "approach": "",
    "pseudo_code": ""
  },
  {
    "sign_no": 221,
    "question": "There are ‘N’ children and ‘M’ cookies.\n\n\nYou are given two arrays, ‘SIZE’, and ‘GREED’, where ‘GREED[i]’ is the greed of ‘ith’ children and ‘SIZE[j]’ is the size of the ‘jth’ cookie.\n\n\nYou must assign ‘jth’ cookie to ‘ith’ child such that the greed of maximum children is satisfied. A child's greed is satisfied if the size of the cookie assigned to him is greater than or equal to his greed.\n\n\nYou must return the maximum number of children whose greed can be satisfied.",
    "name": "Assign Cookies",
    "topic": "greedy",
    "level": "easy",
    "url": "https://leetcode.com/problems/assign-cookies/",
    "approach": "sort both array..then take two pointer i for greed and j for size..\nand check condition and move pointer accordingly",
    "pseudo_code": "Function assignCookie(greed, size):\nSort greed in non-decreasing order\nSort size in non-decreasing order\nInitialize i to 0, j to 0\nInitialize n to the size of greed, m to the size of size\nInitialize ans to 0\n\nWhile i < n and j < m:\nIf size[j] >= greed[i]:\nIncrement ans by 1\nIncrement i by 1\nIncrement j by 1\nElse:\nIncrement j by 1\n\nReturn ans"
  },
  {
    "sign_no": 222,
    "question": "You have been given weights and values of ‘N’ items. You are also given a knapsack of size ‘W’.\n\nYour task is to put the items in the knapsack such that the total value of items in the knapsack is maximum.\nNote:\n\nYou are allowed to break the items.",
    "name": "Fractional Knapsack Problem",
    "topic": "greedy",
    "level": "medium",
    "url": "https://practice.geeksforgeeks.org/problems/fractional-knapsack-1587115620/1",
    "approach": "sort array of pairs according to value per weight ...a.second/a.first > b.second/b.first;\ntake care of double also..\nin fraction knapsack we can take fraction weight also unlike 0/1 knapsack\nadd to the value to ans and weight too..if at any iteratino weight + a[i].first (weight) > size of knapsack then we take the faction value...ans += (w - weight)*(value per weight);\nif we have to take fraction then no need to be in loop so we can get out and have out ans as max value;",
    "pseudo_code": "Function compare(a, b):\nReturn (a.second / a.first) > (b.second / b.first)\n\nFunction maximumValue(items, n, w):\nSort items based on the ratio of value to weight in non-increasing order using the compare function\n\nInitialize ans to 0.0\nInitialize weight to 0.0\n\nFor each item in items:\nIf weight + item.first > w:\nCalculate the value per unit weight for the current item and store it in perval\nUpdate ans by adding (w - weight) * perval (as only a fraction of the item can be added to the knapsack to reach the weight limit)\nBreak out of the loop\nIncrement weight by item.first\nUpdate ans by adding item.second\n\nReturn ans"
  },
  {
    "sign_no": 223,
    "question": "Given an infinite supply of Indian currency i.e. [1, 2, 5, 10, 20, 50, 100, 500, 1000] valued coins and an amount 'N'.\n\n\nFind the minimum coins needed to make the sum equal to 'N'. You have to return the list containing the value of coins required in decreasing order.\n\n\nFor Example\n\nFor Amount = 70, the minimum number of coins required is 2 i.e an Rs. 50 coin and a Rs. 20 coin.\n\nNote\n\nIt is always possible to find the minimum number of coins for the given amount. So, the answer will always exist.",
    "name": "Greedy algorithm to find minimum number of coins",
    "topic": "greedy",
    "level": "medium",
    "url": "https://www.geeksforgeeks.org/find-minimum-number-of-coins-that-make-a-change/",
    "approach": "make an array containing all currency in decreasing order..\nwhile n...let temp = n;\nthen divide temp with current coin will give the number of coin required.\nthen add that coin to ans required times..then you can simpy update n to n%coin...",
    "pseudo_code": "Function MinimumCoins(n):\nInitialize an array arr containing the denominations of coins in decreasing order: {1000, 500, 100, 50, 20, 10, 5, 2, 1}\nInitialize an empty vector ans to store the minimum number of coins\nInitialize i to 0\n\nWhile n is non-zero:\nInitialize temp to n\nCalculate the number of coins needed for the current denomination by dividing temp by arr[i] and store it in c\nFor j from 1 to c:\nAppend arr[i] to ans\nUpdate n by taking the remainder when divided by arr[i]\nIncrement i by 1\n\nReturn ans"
  },
  {
    "sign_no": 224,
    "question": "Ninja is a lemonade seller, and all the lemonade costs 5 rupees for each product. The amount paid by each customer will be 5, 10, or 20 rupees.\n\n\nYou are given an array ‘bill’ of length ‘N’, where ‘bill[i]’ represents the amount paid by the ‘i’th customer. You must return the extra amount to the customers in the order they appear in the bill.\n\n\nGiven the array ‘bill’, you must return whether or not Ninja can return the correct change to all the customers.",
    "name": "Lemonade Change",
    "topic": "greedy",
    "level": "easy",
    "url": "https://leetcode.com/problems/lemonade-change/",
    "approach": "iterate through array and store five and tens number of coins in two variable;\nif bill is 5 then five++;\nif bill is 10 then check if we have any 5 if yes then five--; ten++;\nelse u can return false;\nif bill is 20 then either we can return one 10 and 5 or three 5's but first we will be greedy and check for one 10 and 5 if not then only we check for three 5's if both not then reeturn false",
    "pseudo_code": "Function lemonadeChange(bill):\nInitialize variables five and tens to 0\nInitialize n to the size of bill\n\nFor each customer in bill:\nIf the customer pays with a $5 bill:\nIncrement the count of $5 bills (five)\nElse if the customer pays with a $10 bill:\nIncrement the count of $10 bills (tens)\nIf there's at least one $5 bill available:\nDecrement the count of $5 bills (five)\nElse, return false (unable to provide change)\nElse if the customer pays with a $20 bill:\nIf there's at least one $10 bill and one $5 bill available:\nDecrement the count of $10 bills (tens)\nDecrement the count of $5 bills (five)\nElse if there are at least three $5 bills available:\nDecrement the count of $5 bills by 3 (five)\nElse, return false (unable to provide change)\n\nReturn true (able to provide change to each customer)"
  },
  {
    "sign_no": 225,
    "question": "Given an expression string 's', check whether the pairs and orders of {}, (), and [] brackets are correct. If the brackets are balanced, the function should return true; otherwise, it should return false.",
    "name": "Valid Paranthesis Checker",
    "topic": "greedy",
    "level": "medium",
    "url": "https://leetcode.com/problems/valid-parenthesis-string/",
    "approach": "use stack to store the prev brackets...and check on every iteration weather the current char open brac or if close then is it valid with the char at top of stack..if not then return false...else return true at end...",
    "pseudo_code": "Function isBalanced(s):\nInitialize a stack stk to store opening parentheses\nInitialize n to the size of the string s\n\nFor each character c in s:\nIf c is an opening parenthesis ('{', '[', '('):\nPush c onto the stack stk\nContinue to the next iteration\nElse if stk is empty:\nReturn false (unbalanced parentheses)\nElse if c is a closing parenthesis:\nIf stk is empty, return false (unbalanced parentheses)\nIf the top of the stack stk does not match the corresponding opening parenthesis for c:\nReturn false (unbalanced parentheses)\nPop the top element from the stack stk\n\nIf stk is not empty:\nReturn false (unbalanced parentheses)\nElse:\nReturn true (balanced parentheses)"
  },
  {
    "sign_no": 226,
    "question": "You are given the schedule of 'N' meetings with their start time 'Start[i]' and end time 'End[i]'.\n\nYou have only 1 meeting room. So, you need to return the maximum number of meetings you can organize.\nNote:\nThe start time of one chosen meeting can’t be equal to the end time of the other chosen meeting.",
    "name": "N meetings in one room",
    "topic": "greedy",
    "level": "medium",
    "url": "https://practice.geeksforgeeks.org/problems/n-meetings-in-one-room-1587115620/1",
    "approach": "make a new array of pair from given arrays..\nsort the new array \nthen you can iterate through it and check if a[i]th interval overlaps with a[i+1]th ..if yes then take the one that ends first.",
    "pseudo_code": "Function maximumMeetings(start, end):\nInitialize a vector of pairs temp to store the start and end times of meetings\nFor each index i from 0 to the size of start minus 1:\nAppend a pair (start[i], end[i]) to temp\n\nSort temp in non-decreasing order of start times\n\nInitialize ans to 1 (at least one meeting is possible)\nFor each index i from 0 to the size of temp minus 2:\nIf the end time of the current meeting (temp[i].second) is greater than or equal to the start time of the next meeting (temp[i+1].first):\nUpdate the end time of the next meeting (temp[i+1].second) to be the minimum of its current end time and the end time of the current meeting (temp[i].second)\nElse:\nIncrement ans (a new meeting is needed)\n\nReturn ans"
  },
  {
    "sign_no": 227,
    "question": "There is an array 'JUMP' of size 'N' which is 1-indexed and you are currently at index 1. Your goal is to reach index 'N' (end).\n\n\nWhen you are at index 'i', you can jump a maximum length of 'JUMP[i]' which means you can make a jump of size 1 to JUMP[i]. Return true if you can reach the end otherwise false.",
    "name": "Jump Game",
    "topic": "greedy",
    "level": "medium",
    "url": "https://leetcode.com/problems/jump-game/",
    "approach": "take a variable minJumRequired...we will iterate the array from right and find out the min jum required to get to the end...as at index n-1 minre.. = 0...we will decrease i and increase minreq by 1...if the jum at current index is >= minreq..then we know that from that index we can get to the next indexes that will get us to then end...so we set minreq = 0 and iterate the array as it is ...\nthen at last if minreq is 0 then return true else return false;",
    "pseudo_code": "Function jump_search(jump, n):\nInitialize minreq to 0\nIterate i from n - 2 down to 0:\nIncrement minreq by 1\nIf minreq is less than or equal to jump[i], set minreq to 0\n\nIf minreq is equal to 0, return true (able to jump to the end)\nOtherwise, return false (unable to jump further)"
  },
  {
    "sign_no": 228,
    "question": "You have been given an array 'ARR' of ‘N’ integers. You have to return the minimum number of jumps needed to reach the last index of the array i.e ‘N - 1’.\n\n\nFrom index ‘i’, we can jump to an index ‘i + k’ such that 1<= ‘k’ <= ARR[i] .\n\n\n'ARR[i]' represents the maximum distance you can jump from the current index.\n\n\nIf it is not possible to reach the last index, return -1.",
    "name": "Jump Game 2",
    "topic": "greedy",
    "level": "medium",
    "url": "https://leetcode.com/problems/jump-game-ii/",
    "approach": "",
    "pseudo_code": ""
  },
  {
    "sign_no": 229,
    "question": "You have been given two arrays, 'AT' and 'DT', representing the arrival and departure times of all trains that reach a railway station.\n\nYour task is to find the minimum number of platforms required for the railway station so that no train needs to wait.\nNote :\n\n1. Every train will depart on the same day and the departure time will always be greater than the arrival time. For example, A train with arrival time 2240 and departure time 1930 is not possible.\n\n2. Time will be given in 24H format and colons will be omitted for convenience. For example, 9:05AM will be given as \"905\", or 9:10PM will be given as \"2110\".\n\n3. Also, there will be no leading zeroes in the given times. For example, 12:10AM will be given as “10” and not as “0010”.",
    "name": "Minimum number of platforms required for a railway",
    "topic": "greedy",
    "level": "medium",
    "url": "https://practice.geeksforgeeks.org/problems/minimum-platforms-1587115620/1#",
    "approach": "we have the arrival and departure of all the trains...so we only have to find the max no of platoform\nrequired and not about wich train ..so we will sort both the arrays..\nat start let result be 1, plat be 1 and take two pointers i=1, j=0;\ncheck if the departure b[j] >= a[j] (arrival) then we will need more platform so plat++;\nelse plat--;\nat last we can update the result to be max of result and plat;",
    "pseudo_code": "Function calculateMinPlatforms(a, b, n):\nSort the arrival times array a in non-decreasing order\nSort the departure times array b in non-decreasing order\n\nInitialize result to 1, i to 1, j to 0, and plat to 1\n\nWhile i is less than n and j is less than n:\nIf the arrival time of the next train (a[i]) is less than or equal to the departure time of the current train (b[j]):\nIncrement plat by 1\nIncrement i by 1\nElse:\nDecrement plat by 1\nIncrement j by 1\n\nUpdate result to be the maximum of result and plat\n\nReturn result"
  },
  {
    "sign_no": 230,
    "question": "You are given a 'Nx3' 2-D array 'Jobs' describing 'N' jobs where 'Jobs[i][0]' denotes the id of 'i-th' job, 'Jobs[i][1]' denotes the deadline of 'i-th' job, and 'Jobs[i][2]' denotes the profit associated with 'i-th job'.\n\n\nYou will make a particular profit if you complete the job within the deadline associated with it. Each job takes 1 unit of time to be completed, and you can schedule only one job at a particular time.\n\n\nReturn the number of jobs to be done to get maximum profit.\n\n\nNote :\n\nIf a particular job has a deadline 'x', it means that it needs to be completed at any time before 'x'.\n\nAssume that the start time is 0.",
    "name": "Job sequencing Problem",
    "topic": "greedy",
    "level": "medium",
    "url": "https://practice.geeksforgeeks.org/problems/job-sequencing-problem-1587115620/1#",
    "approach": "sort the array according to profit descendingly.\nfind the max deadline ...no jobs can be done after that deadline ..so create a new array of length \nmax deadline + 1 so we can assign jobs for each deadline.\niterate through sorted array and for each job put iit at its deadline..if there is a job already at its deadline then decrease the iterator to put it lower deadlines...if no deadline present for that job then skip it.\nwhile doing this we can count the jobs and maxprofit done.",
    "pseudo_code": "Function jobScheduling(jobs):\nSort the jobs array in non-increasing order of profit using custom comparator function compare\n\nSet n to the size of jobs array\n\nInitialize maxDeadline to the deadline of the first job\nFor each job in jobs:\nUpdate maxDeadline to be the maximum of maxDeadline and the deadline of the current job\n\nCreate a vector v of size maxDeadline + 1, initialized with -1\n\nInitialize jobsCnt and maxProfit to 0\n\nFor each job in jobs:\nIterate from the deadline of the current job down to 1:\nIf v[j] is equal to -1 (i.e., the slot is empty):\nAssign the job to slot j\nIncrement jobsCnt by 1\nAdd the profit of the current job to maxProfit\nBreak the loop\n\nReturn a vector containing jobsCnt and maxProfit"
  },
  {
    "sign_no": 231,
    "question": "Prateek is a kindergarten teacher. He wants to give some candies to the children in his class. All the children stand in a line and each of them has a grade according to his or her performance in the class. Prateek wants to give at least one candy to each child. If two children are standing adjacent to each other, then the one with the higher rating must get more candies than the other. Prateek wants to minimize the total number of candies he must buy.\n\nGiven an array 'STUDENTS' of size 'N' that contains the grades for each student, your task is to find what is the minimum number of candies Prateek must buy so that he can distribute them among his students according to the criteria given above.",
    "name": "Candy",
    "topic": "greedy",
    "level": "hard",
    "url": "https://leetcode.com/problems/candy/",
    "approach": "we can store the number of candies in a new array ..\nneed 2 pass,,,in 1 pass we will check for right element to be grater then left and in \nanother pass we will check for left element to be greater then right...",
    "pseudo_code": "Function requiredCandies(a):\nInitialize n to the size of array a\nCreate a vector candi of size n, initialized with 1 (each child gets at least 1 candy)\n\nIterate i from 0 to n-2:\nIf the rating of the current child (a[i]) is less than the rating of the next child (a[i+1]):\nAssign the maximum of 1 and the number of candies given to the current child to the next child (candi[i+1] = max(1, candi[i]) + 1)\n\nIterate i from n-1 down to 1:\nIf the rating of the current child (a[i]) is less than the rating of the previous child (a[i-1]):\nIf the number of candies given to the previous child is less than or equal to the number of candies given to the current child:\nAssign the number of candies given to the current child to the previous child plus 1 (candi[i-1] = candi[i] + 1)\n\nCalculate the sum of all elements in the candi vector and return it as the result"
  },
  {
    "sign_no": 232,
    "question": "Problem statement\n\nYou have to implement the shortest job first scheduling algorithm.\n\n\nShortest Job First is an algorithm in which the process having the smallest execution(burst) time is chosen for the next execution. Here, you will implement a non - preemptive version (a process will wait till process(es) with shorter burst time executes). You have to return the average waiting for the given number of processes.\n\n\nCompletion Time: Time at which process completes its execution.",
    "name": "Program for Shortest Job First (or SJF) CPU Scheduling",
    "topic": "greedy",
    "level": "medium",
    "url": "https://bit.ly/3DYCIFb",
    "approach": "",
    "pseudo_code": ""
  },
  {
    "sign_no": 234,
    "question": "You are given a 2-dimensional array ‘Intervals’ containing a list of non-overlapping intervals sorted by their start time. You are given an interval ‘newInterval’. Your task is to insert the given interval at the correct position and merge all necessary intervals to produce a list with only mutually exclusive intervals.\nFor Example:\n\nConsider 'Intervals' = [[1, 3], [5, 7], [8, 12]], and 'newInterval' = [4, 6] \nThe interval [4, 6] overlaps with [5, 7]. Therefore we can merge the intervals and produce an interval [4, 7]. Hence the answer [[1,3], [4,7], [8,12]]",
    "name": "Insert Interval",
    "topic": "greedy",
    "level": "medium",
    "url": "https://leetcode.com/problems/insert-interval/",
    "approach": "the new interval can be either smaller or bigger or overlapping...so if its smaller then push the new interval the push all the remaining and return ans;\nif its bigger then push the current interval\nif its overlapping then change the new interval to min and max values merging both intervals...\nat then end push the new interval(may be changes or not) then return ans;",
    "pseudo_code": "Function addInterval(a, n, ni):\nInitialize an empty 2D vector ans to store the merged intervals\n\nIterate i from 0 to n-1:\nIf the start of the current interval in a (a[i][0]) is greater than the end of the new interval (ni[1]):\nAppend the new interval ni to ans\nAppend the remaining intervals from a to ans\nReturn ans\n\nIf the end of the current interval in a (a[i][1]) is less than the start of the new interval (ni[0]):\nAppend the current interval in a to ans\n\nOtherwise (if there's an overlap between the current interval in a and the new interval ni):\nUpdate the start of ni to be the minimum of the current interval's start and ni's start\nUpdate the end of ni to be the maximum of the current interval's end and ni's end\n\nIf there's no interval in a that can be merged with ni:\nAppend ni to ans\n\nReturn ans"
  },
  {
    "sign_no": 235,
    "question": "You are given N number of intervals, where each interval contains two integers denoting the start time and the end time for the interval.\n\nThe task is to merge all the overlapping intervals and return the list of merged intervals sorted by increasing order of their start time.\n\nTwo intervals [A,B] and [C,D] are said to be overlapping with each other if there is at least one integer that is covered by both of them.\n\nFor example:\n\nFor the given 5 intervals - [1, 4], [3, 5], [6, 8], [10, 12], [8, 9].\n\nSince intervals [1, 4] and [3, 5] overlap with each other, we will merge them into a single interval as [1, 5].\n\nSimilarly, [6, 8] and [8, 9] overlap, merge them into [6,9].\n\nInterval [10, 12] does not overlap with any interval.\n\nFinal List after merging overlapping intervals: [1, 5], [6, 9], [10, 12].",
    "name": "Merge Intervals",
    "topic": "greedy",
    "level": "medium",
    "url": "https://leetcode.com/problems/merge-intervals/",
    "approach": "sort them by start in increasing order....if ans array is empty then push a[i] else \ncheck if they overlap..ans.back()[1] >= a[1][0] then they overlaps..so merge them ;\nelse puch the a[i];",
    "pseudo_code": "Function mergeIntervals(a):\nSort the intervals in non-decreasing order of their start times\n\nInitialize an empty 2D vector ans to store the merged intervals\n\nIterate through each interval i in a:\nIf ans is empty:\nAppend the current interval i to ans\nElse:\nIf the end time of the last interval in ans (ans.back()[1]) is greater than or equal to the start time of the current interval i (a[i][0]):\nUpdate the end time of the last interval in ans to be the maximum of its current end time and the end time of the current interval i (a[i][1])\nElse:\nAppend the current interval i to ans\n\nReturn ans"
  },
  {
    "sign_no": 236,
    "question": "Ninja is the steel factory owner, and there are 'N' workers working at that factory. Each worker has his own working time, and it is provided in the array 'intervals' where 'INTERVALS[i][0]' gives the start time of the 'i'th worker and 'INTERVALS[i][1]' gives the end time of the 'i'th worker.\n\nNinja does not want to allow more than one worker to work at the same time, so he needs your help to find the minimum number of workers he needs to reschedule their work time so as there are non-overlapping working times in any two workers.\nExample:\"There are ‘N’ children and ‘M’ cookies.\n\n\nYou are given two arrays, ‘SIZE’, and ‘GREED’, where ‘GREED[i]’ is the greed of ‘ith’ children and ‘SIZE[j]’ is the size of the ‘jth’ cookie.\n\n\nYou must assign ‘jth’ cookie to ‘ith’ child such that the greed of maximum children is satisfied. A child's greed is satisfied if the size of the cookie assigned to him is greater than or equal to his greed.\n\n\nYou must return the maximum number of children whose greed can be satisfied.\"\n\"You have been given weights and values of ‘N’ items. You are also given a knapsack of size ‘W’.\n\nYour task is to put the items in the knapsack such that the total value of items in the knapsack is maximum.\nNote:\n\nYou are allowed to break the items.\"\n\"Given an infinite supply of Indian currency i.e. [1, 2, 5, 10, 20, 50, 100, 500, 1000] valued coins and an amount 'N'.\n\n\nFind the minimum coins needed to make the sum equal to 'N'. You have to return the list containing the value of coins required in decreasing order.\n\n\nFor Example\n\nFor Amount = 70, the minimum number of coins required is 2 i.e an Rs. 50 coin and a Rs. 20 coin.\n\nNote\n\nIt is always possible to find the minimum number of coins for the given amount. So, the answer will always exist.\n\"\n\"Ninja is a lemonade seller, and all the lemonade costs 5 rupees for each product. The amount paid by each customer will be 5, 10, or 20 rupees.\n\n\nYou are given an array ‘bill’ of length ‘N’, where ‘bill[i]’ represents the amount paid by the ‘i’th customer. You must return the extra amount to the customers in the order they appear in the bill.\n\n\nGiven the array ‘bill’, you must return whether or not Ninja can return the correct change to all the customers.\"\nGiven an expression string 's', check whether the pairs and orders of {}, (), and [] brackets are correct. If the brackets are balanced, the function should return true; otherwise, it should return false.\n\"You are given the schedule of 'N' meetings with their start time 'Start[i]' and end time 'End[i]'.\n\nYou have only 1 meeting room. So, you need to return the maximum number of meetings you can organize.\nNote:\nThe start time of one chosen meeting can’t be equal to the end time of the other chosen meeting.\"\n\"There is an array 'JUMP' of size 'N' which is 1-indexed and you are currently at index 1. Your goal is to reach index 'N' (end).\n\n\nWhen you are at index 'i', you can jump a maximum length of 'JUMP[i]' which means you can make a jump of size 1 to JUMP[i]. Return true if you can reach the end otherwise false.\"\n\"You have been given an array 'ARR' of ‘N’ integers. You have to return the minimum number of jumps needed to reach the last index of the array i.e ‘N - 1’.\n\n\nFrom index ‘i’, we can jump to an index ‘i + k’ such that 1<= ‘k’ <= ARR[i] .\n\n\n'ARR[i]' represents the maximum distance you can jump from the current index.\n\n\nIf it is not possible to reach the last index, return -1.\"\n\"You have been given two arrays, 'AT' and 'DT', representing the arrival and departure times of all trains that reach a railway station.\n\nYour task is to find the minimum number of platforms required for the railway station so that no train needs to wait.\nNote :\n\n1. Every train will depart on the same day and the departure time will always be greater than the arrival time. For example, A train with arrival time 2240 and departure time 1930 is not possible.\n\n2. Time will be given in 24H format and colons will be omitted for convenience. For example, 9:05AM will be given as \"\"905\"\", or 9:10PM will be given as \"\"2110\"\".\n\n3. Also, there will be no leading zeroes in the given times. For example, 12:10AM will be given as “10” and not as “0010”.\"\n\"You are given a 'Nx3' 2-D array 'Jobs' describing 'N' jobs where 'Jobs[i][0]' denotes the id of 'i-th' job, 'Jobs[i][1]' denotes the deadline of 'i-th' job, and 'Jobs[i][2]' denotes the profit associated with 'i-th job'.\n\n\nYou will make a particular profit if you complete the job within the deadline associated with it. Each job takes 1 unit of time to be completed, and you can schedule only one job at a particular time.\n\n\nReturn the number of jobs to be done to get maximum profit.\n\n\nNote :\n\nIf a particular job has a deadline 'x', it means that it needs to be completed at any time before 'x'.\n\nAssume that the start time is 0.\"\n\"Prateek is a kindergarten teacher. He wants to give some candies to the children in his class. All the children stand in a line and each of them has a grade according to his or her performance in the class. Prateek wants to give at least one candy to each child. If two children are standing adjacent to each other, then the one with the higher rating must get more candies than the other. Prateek wants to minimize the total number of candies he must buy.\n\nGiven an array 'STUDENTS' of size 'N' that contains the grades for each student, your task is to find what is the minimum number of candies Prateek must buy so that he can distribute them among his students according to the criteria given above.\"\n\" Problem statement\n\nYou have to implement the shortest job first scheduling algorithm.\n\n\nShortest Job First is an algorithm in which the process having the smallest execution(burst) time is chosen for the next execution. Here, you will implement a non - preemptive version (a process will wait till process(es) with shorter burst time executes). You have to return the average waiting for the given number of processes.\n\n\nCompletion Time: Time at which process completes its execution.\"\n\"You are given a 2-dimensional array ‘Intervals’ containing a list of non-overlapping intervals sorted by their start time. You are given an interval ‘newInterval’. Your task is to insert the given interval at the correct position and merge all necessary intervals to produce a list with only mutually exclusive intervals.\nFor Example:\n\nConsider 'Intervals' = [[1, 3], [5, 7], [8, 12]], and 'newInterval' = [4, 6] \nThe interval [4, 6] overlaps with [5, 7]. Therefore we can merge the intervals and produce an interval [4, 7]. Hence the answer [[1,3], [4,7], [8,12]]\n\"\n\"You are given N number of intervals, where each interval contains two integers denoting the start time and the end time for the interval.\n\nThe task is to merge all the overlapping intervals and return the list of merged intervals sorted by increasing order of their start time.\n\nTwo intervals [A,B] and [C,D] are said to be overlapping with each other if there is at least one integer that is covered by both of them.\n\nFor example:\n\nFor the given 5 intervals - [1, 4], [3, 5], [6, 8], [10, 12], [8, 9].\n\nSince intervals [1, 4] and [3, 5] overlap with each other, we will merge them into a single interval as [1, 5].\n\nSimilarly, [6, 8] and [8, 9] overlap, merge them into [6,9].\n\nInterval [10, 12] does not overlap with any interval.\n\nFinal List after merging overlapping intervals: [1, 5], [6, 9], [10, 12].\n\"\n\"Ninja is the steel factory owner, and there are 'N' workers working at that factory. Each worker has his own working time, and it is provided in the array 'intervals' where 'INTERVALS[i][0]' gives the start time of the 'i'th worker and 'INTERVALS[i][1]' gives the end time of the 'i'th worker.\n\nNinja does not want to allow more than one worker to work at the same time, so he needs your help to find the minimum number of workers he needs to reschedule their work time so as there are non-overlapping working times in any two workers.",
    "name": "Non-overlapping Intervals",
    "topic": "greedy",
    "level": "medium",
    "url": "https://leetcode.com/problems/non-overlapping-intervals/",
    "approach": "sort vector...then take a var as last..initially last = a[0][1];\niterate from i = 1 to n;\nif(last > start of current) then increase ans and update last to the one which ends earlier..i.e min(last, a[i][1]);\nelse update last to end of current;",
    "pseudo_code": "Function minimumReschedules(n, a):\nSort the intervals in non-decreasing order of their start times\n\nInitialize ans to 0, to count the number of reschedules needed\nInitialize last to the end time of the first interval in a\n\nIterate through each interval i from the second interval to the last interval in a:\nIf the end time of the last interval (last) is greater than the start time of the current interval i:\nIncrement ans by 1, indicating the need for a reschedule\nUpdate last to be the minimum of the end time of the current interval i and the current value of last\nElse:\nUpdate last to be the end time of the current interval i\n\nReturn ans"
  },
  {
    "sign_no": 237,
    "question": "Given an integer 'N', determine the maximum number of nodes present on 'Nth' level in a binary tree.",
    "name": "Introduction to Trees",
    "topic": "bt",
    "level": "easy",
    "url": "https://bit.ly/3EsRmTM",
    "approach": "the number of max nodes a binary tree's level can have is -> 2^(n-1)",
    "pseudo_code": ""
  },
  {
    "sign_no": 238,
    "question": "Given an array 'arr' that contains 7 integers representing the values of nodes in a binary tree. This represents level order. The first element of the array represents the value of the root node.\n\n\nYour objective is to construct a binary tree using the remaining 6 elements of the array, creating nodes for each of these values and return root node.",
    "name": "Binary Tree Representation in C++",
    "topic": "bt",
    "level": "easy",
    "url": "https://bit.ly/3gn5Soh",
    "approach": "use recursion to convert a vector to binary tree...as i will be the parent of 2*i+1 and 2*i+2 left and right child;\nso we can use recursion to set the left the right child and then their childs...",
    "pseudo_code": "Function helper(arr, i, n):\nIf i is greater than or equal to n, return NULL, indicating an empty node\n\nCreate a new node 'current' with the value arr[i]\n\nSet the left child of 'current' by recursively calling helper with arguments (arr, 2*i+1, n)\nSet the right child of 'current' by recursively calling helper with arguments (arr, 2*i+2, n)\n\nReturn 'current'\n\nFunction createTree(arr):\nCall helper with arguments (arr, 0, size of arr)\n\nReturn the result from helper, which is the root of the binary tree"
  },
  {
    "sign_no": 240,
    "question": "You have been given a Binary Tree of 'N'\n\nnodes, where the nodes have integer values.\n\n\nYour task is to return the ln-Order, Pre-Order, and Post-Order traversals of the given binary tree.",
    "name": "Binary Tree Traversals in Binary Tree",
    "topic": "bt",
    "level": "easy",
    "url": "https://www.codingninjas.com/codestudio/problems/tree-traversal_981269?utm_source=striver&utm_medium=website&utm_campaign=a_zcoursetuf",
    "approach": "use recursion to traverse the tree...\ninorder > left , root, right\npre -> root, left, right\npost -> left, right, root;\nbase casee -> root == null then return..\ninorder -> go left, pust data, then go right\npre -> push dta , go left , go right\npost -> go left, go right , push data",
    "pseudo_code": "Function traverse(root, ino, preo, posto):\nIf root is NULL, return\n\nAppend the data of root to the preorder traversal list 'preo'\nRecursively call traverse with root's left child, passing ino, preo, and posto lists\nAppend the data of root to the inorder traversal list 'ino'\nRecursively call traverse with root's right child, passing ino, preo, and posto lists\nAppend the data of root to the postorder traversal list 'posto'\n\nFunction getTreeTraversal(root):\nInitialize empty lists ino, preo, and posto to store inorder, preorder, and postorder traversals respectively\nCall traverse with root, ino, preo, and posto lists\nCreate a 2D vector 'ans' and append ino, preo, and posto lists to it\nReturn 'ans'"
  },
  {
    "sign_no": 241,
    "question": "pre order traversal",
    "name": "Preorder Traversal of Binary Tree",
    "topic": "bt",
    "level": "easy",
    "url": "https://leetcode.com/problems/binary-tree-preorder-traversal/",
    "approach": "",
    "pseudo_code": "-"
  },
  {
    "sign_no": 242,
    "question": "inorder traversal",
    "name": "Inorder Traversal of Binary Tree",
    "topic": "bt",
    "level": "easy",
    "url": "https://leetcode.com/problems/binary-tree-inorder-traversal/",
    "approach": "",
    "pseudo_code": "-"
  },
  {
    "sign_no": 243,
    "question": "post order traversal",
    "name": "Post-order Traversal of Binary Tree",
    "topic": "bt",
    "level": "easy",
    "url": "https://leetcode.com/problems/binary-tree-postorder-traversal/",
    "approach": "",
    "pseudo_code": "-"
  },
  {
    "sign_no": 244,
    "question": "level order traversal",
    "name": "Level order Traversal / Level order traversal in spiral form",
    "topic": "bt",
    "level": "easy",
    "url": "https://leetcode.com/problems/binary-tree-level-order-traversal/",
    "approach": "use queue to store the current level nodes...\npush the root to q and loop until q is empty..run another loop inside for current level...for i=0 to q.size();\nthen take the front of queue and pop it...if the front has left or right child push them to queue..\nat end push the value of front to our ans...",
    "pseudo_code": "Function levelOrder(root):\nCreate an empty vector 'ans' to store the level-order traversal result\nCreate an empty queue 'q' to perform level-order traversal\n\nIf root is NULL, return empty 'ans'\n\nEnqueue the root node into the queue 'q'\n\nWhile the queue 'q' is not empty:\nGet the size of the queue 'q' and store it in 'sz'\n\nIterate 'i' from 0 to 'sz-1':\nDequeue a node 'top' from the front of the queue 'q'\nIf 'top' has a left child, enqueue it into 'q'\nIf 'top' has a right child, enqueue it into 'q'\nAppend the data of 'top' to the 'ans' vector\n\nReturn the 'ans' vector containing the level-order traversal result"
  },
  {
    "sign_no": 245,
    "question": "iiterative preorder traversal",
    "name": "Iterative Preorder Traversal of Binary Tree",
    "topic": "bt",
    "level": "easy",
    "url": "https://leetcode.com/problems/binary-tree-preorder-traversal/",
    "approach": "use stack ....\npush root..while stack not empty loop\ntake top..pop top and put right and left child to stack....in order ..\nright then left so the next element we needed is the left one which will be on top of stack.",
    "pseudo_code": "Function preOrder(root):\nCreate an empty vector 'ans' to store the preorder traversal result\nCreate an empty stack 'stk' to perform preorder traversal\n\nIf root is NULL, return empty 'ans'\n\nPush the root node onto the stack 'stk'\n\nWhile the stack 'stk' is not empty:\nPop a node 'top' from the top of the stack 'stk'\nAppend the data of 'top' to the 'ans' vector\n\nIf 'top' has a right child, push it onto the stack 'stk'\nIf 'top' has a left child, push it onto the stack 'stk'\n\nReturn the 'ans' vector containing the preorder traversal result"
  },
  {
    "sign_no": 246,
    "question": "iterative inorder traversal",
    "name": "Iterative Inorder Traversal of Binary Tree",
    "topic": "bt",
    "level": "easy",
    "url": "https://leetcode.com/problems/binary-tree-inorder-traversal/",
    "approach": "use stack..loop infinitely...if root ..then push root to stk and go to left..\nif root is null then it means we are at extreme left...so the top of the stack will be out parent that we have to push to the ans ..\nso root = stk.top..stk.pop..push root.val and go to right of the root now...root = root -> right;\nif stack becomes empty then you can break out of the loop.",
    "pseudo_code": "Function getInOrderTraversal(root):\nCreate an empty stack 'stk' to perform inorder traversal\nCreate an empty vector 'ans' to store the inorder traversal result\n\nLoop indefinitely:\nIf 'root' is not NULL:\nPush 'root' onto the stack 'stk'\nMove 'root' to its left child\n\nElse (if 'root' is NULL):\nIf the stack 'stk' is empty, return 'ans'\n\nPop a node 'top' from the top of the stack 'stk'\nAppend the data of 'top' to the 'ans' vector\nMove 'root' to the right child of 'top'\n\nReturn the 'ans' vector containing the inorder traversal result"
  },
  {
    "sign_no": 247,
    "question": "iterative postorder traversal",
    "name": "Post-order Traversal of Binary Tree using 2 stack",
    "topic": "bt",
    "level": "easy",
    "url": "https://leetcode.com/problems/binary-tree-postorder-traversal/",
    "approach": "use two stack..push root..while not s1.empty() take top pop top push left and right to s1 then push top to s2...after pop s2 while not empty and push each data to ans vector...its will be our anser\nhere we are traversing left then right then root...to follow post order rule",
    "pseudo_code": "Function postorderTraversal(root):\nCreate two stacks 's1' and 's2' to perform postorder traversal\nCreate an empty vector 'ans' to store the postorder traversal result\nPush the 'root' node onto the stack 's1'\n\nLoop while stack 's1' is not empty:\nPop a node 'top' from the top of stack 's1'\nIf 'top' is not NULL:\nPush the left child of 'top' onto stack 's1' (if exists)\nPush the right child of 'top' onto stack 's1' (if exists)\nPush 'top' onto stack 's2' to reverse the order for postorder traversal\n\nLoop while stack 's2' is not empty:\nPop a node 'top' from the top of stack 's2'\nAppend the data of 'top' to the 'ans' vector\n\nReturn the 'ans' vector containing the postorder traversal result"
  },
  {
    "sign_no": 248,
    "question": "in, pre, post..at once in single iteration....",
    "name": "Post-order Traversal of Binary Tree using 1 stack",
    "topic": "bt",
    "level": "medium",
    "url": "https://leetcode.com/problems/binary-tree-postorder-traversal/",
    "approach": "use 1 stack..push root..then loop until stack is empty...\ntake the top..pop the top...we will store a pair in the stack..\n<TreeNode*, int> the int will show a number which will tell us about its order...pre=1, ino=2, posto=3\nif the num is 1 then push the data of top to pre, update the int..top.second++...then push the top again to stack then \nif the top has left child then push it also with num=1,\nsimiler for right...if num==2, in inorder...update second...push again to s...then go to right\nif num == 3 that means we don't have to push it to stack again as we are traversing it 3rd time...for post...so just push to post\nat end push all the ino, pre, posto to ans vector....",
    "pseudo_code": "Function getTreeTraversal(root):\nCreate a stack 's' to perform iterative tree traversal\nCreate vectors 'preo', 'ino', and 'posto' to store traversal results\nCreate a 2D vector 'ans' to store all traversal results\n\nPush the pair (root, 1) onto stack 's' with state 1 indicating preorder traversal\nWhile stack 's' is not empty:\nPop the top pair 'top' from stack 's'\nIf 'top' has state 1:\nAppend the data of 'top.first' to 'preo' vector\nIncrement 'top.second' to state 2 for inorder traversal\nPush 'top' back onto stack 's'\nIf 'top.first' has a left child:\nPush the pair (left child, 1) onto stack 's' for preorder traversal\nElse if 'top' has state 2:\nAppend the data of 'top.first' to 'ino' vector\nIncrement 'top.second' to state 3 for postorder traversal\nPush 'top' back onto stack 's'\nIf 'top.first' has a right child:\nPush the pair (right child, 1) onto stack 's' for preorder traversal\nElse (state 3):\nAppend the data of 'top.first' to 'posto' vector\n\nAppend vectors 'ino', 'preo', and 'posto' to the 'ans' vector\n\nReturn 'ans' containing all traversal results"
  },
  {
    "sign_no": 250,
    "question": "The height of a tree is equal to the number of nodes on the longest path from the root to a leaf.\n\n\nYou are given an arbitrary binary tree consisting of 'n' nodes where each node is associated with a certain value.\n\n\nFind out the height of the tree",
    "name": "Height of a Binary Tree",
    "topic": "bt",
    "level": "medium",
    "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/",
    "approach": "#1. new recursive functin...take a var i at 0 and go to left and right until root become null\nand increase the value of i each time\nif root == null that means we are at end so return i;\nthen store the left and right for each call and return the max of left or right\n\n#2 iterate left and right...if null then return 0;\nstore left and right...then return max(leftm right) + 1;\nhere if its a leaf node then we can see its height will be 1 and it will return 1 to its parent then its parent height will be max(left, right) + 1..lets say 2 and that's the intuation.",
    "pseudo_code": "int heightOfBinaryTree(TreeNode<int> *root)\n{\n// Base case: if the current node is NULL, return 0\nif (!root) return 0;\n\n// Recursively calculate the height of the left subtree\nint lh = heightOfBinaryTree(root->left);\n// Recursively calculate the height of the right subtree\nint rh = heightOfBinaryTree(root->right);\n\n// Return the maximum height of the left and right subtrees, plus 1 for the current node\nreturn max(lh, rh) + 1;\n}"
  },
  {
    "sign_no": 251,
    "question": "You are given the root node of a binary tree.\n\n\nReturn 'true' if it is a height balanced binary tree.\n\n\nNote:\n\nHeight of a tree is the maximum number of nodes in a path from the node to the leaf node.\n\nAn empty tree is a height-balanced tree. A non-empty binary tree is a height-balanced binary tree if\n1. The left subtree of a binary tree is already the height-balanced tree.\n2. The right subtree of a binary tree is also the height-balanced tree.\n3. The difference between heights of left subtree and right subtree must not more than ‘1’.",
    "name": "Check if the Binary tree is height-balanced or not",
    "topic": "bt",
    "level": "medium",
    "url": "https://leetcode.com/problems/balanced-binary-tree/",
    "approach": "find height of each sub tree using recursion...\nthen find out if abs(left - right) > 1 then return -1...\nif any of left or right is -1 then also return -1\nif not then you can return the height of the tree..as it is\nat end if the root's height is -1 then we can say there must be a subtree which is not balanced so return false\nelse return true",
    "pseudo_code": "int treeHeight(TreeNode<int>* root){\n// Base case: if the current node is NULL, return 0\nif (!root) return 0;\n\n// Recursively calculate the height of the left subtree\nint lh = treeHeight(root->left);\n\n// If the left subtree is unbalanced, return -1\nif (lh == -1) return -1;\n\n// Recursively calculate the height of the right subtree\nint rh = treeHeight(root->right);\n\n// If the right subtree is unbalanced, return -1\nif (rh == -1) return -1;\n\n// If the absolute difference in heights of left and right subtrees is greater than 1, return -1\nif (abs(lh - rh) > 1) return -1;\n\n// Return the maximum height of left and right subtrees, plus 1 for the current node\nreturn max(lh, rh) + 1;\n}\n\n\n\nbool isBalancedBT(TreeNode<int>* root){\n// If the tree height is -1, it is unbalanced; otherwise, it is balanced\nreturn treeHeight(root) != -1;\n}"
  },
  {
    "sign_no": 252,
    "question": "You are given a Binary Tree.\n\n\nReturn the length of the diameter of the tree.\n\n\nNote :\n\nThe diameter of a binary tree is the length of the longest path between any two end nodes in a tree.\n\nThe number of edges between two nodes represents the length of the path between them.",
    "name": "Diameter of Binary Tree",
    "topic": "bt",
    "level": "medium",
    "url": "https://leetcode.com/problems/diameter-of-binary-tree/",
    "approach": "the diameter of tree is the longest length between two end nodes\nthe length is the number of edges between\n\nso for tree the diamater will be the height and the 2nd max height sum\nso for a node..the diamater will be the max height of left + max height of right subtree\nhence we can store the diamater in a variabler (global or reference)",
    "pseudo_code": "int heights(TreeNode<int> *root, int &maxi){\n// Base case: if the current node is NULL, return 0\nif (!root) return 0;\n\n// Recursively calculate the height of the left subtree\nint lh = heights(root->left, maxi);\n\n// Recursively calculate the height of the right subtree\nint rh = heights(root->right, maxi);\n\n// Update the maximum diameter found so far\nmaxi = max(maxi, lh + rh);\n\n// Return the height of the current subtree\nreturn max(lh, rh) + 1;\n}\n\n\n\n\nint diameterOfBinaryTree(TreeNode<int> *root){\nint maxi = 0;\n\n// Call the heights function to calculate the diameter of the binary tree\nheights(root, maxi);\n\n// Return the maximum diameter found\nreturn maxi; \n}"
  },
  {
    "sign_no": 253,
    "question": "You are given a binary tree having 'n' nodes. Each node of the tree has an integer value.\n\n\nYour task is to find the maximum possible sum of a simple path between any two nodes (possibly the same) of the given tree.\n\n\nA simple path is a path between any two nodes of a tree, such that no edge in the path is repeated twice. The sum of a simple path is defined as the summation of all node values in a path.",
    "name": "Maximum path sum",
    "topic": "bt",
    "level": "hard",
    "url": "https://leetcode.com/problems/binary-tree-maximum-path-sum/",
    "approach": "for each node we will find the left max path and right max path\nso we can find out paht with the maxSUm\neach node can be considered as a curve point..so we will find left and right maxSum and have a variable maxi which will store the max sum...now we have updated the maxi but now we have to return a path for parent that is max ...so \nwe return curr->data + max(left, right);\nso now the parent can have a left or right max path that is return by its child to it.",
    "pseudo_code": "int pathSum(BinaryTreeNode<int>* root, int &maxi){\n// Base case: if the current node is NULL, return 0\nif (!root) return 0;\n\n// Recursively calculate the maximum path sum of the left subtree\nint ls = max(0, pathSum(root->left, maxi));\n\n// Recursively calculate the maximum path sum of the right subtree\nint rs = max(0, pathSum(root->right, maxi));\n\n// Update the maximum path sum found so far\nmaxi = max(maxi, root->data + ls + rs);\n\n// Return the maximum path sum starting from the current node\nreturn root->data + max(ls, rs);\n}\n\n\n\n\nint maxPathSum(BinaryTreeNode<int> *root)\n{\nint maxi = INT_MIN; // Initialize maxi with the minimum possible integer value\npathSum(root, maxi); // Call pathSum function to calculate the maximum path sum\nreturn maxi; // Return the maximum path sum found\n}"
  },
  {
    "sign_no": 254,
    "question": "You are given two binary trees with 'n' and 'm' nodes respectively.\n\n\nYou need to return true if the two trees are identical. Otherwise, return false.",
    "name": "Check if two trees are identical or not",
    "topic": "bt",
    "level": "medium",
    "url": "https://leetcode.com/problems/same-tree/",
    "approach": "we need to check for each node if they are identical or not..\nso we use recursion to iterate the tree and go left and right while checking each node\nif root1 is then then root 2 has to be null so if both null then return true;\nif one is null but other is not then return false\nthen check the data ..root1-data != root2-data..if not equal then return false..\nthen go to left...store the bool return by left..similer for right..\nthen return left && right ..as for the tree to be identical its left and right subtree also has to be identical",
    "pseudo_code": "bool identicalTrees(BinaryTreeNode<int>* root1, BinaryTreeNode<int>* root2) {\n// If both roots are NULL, the trees are identical\nif (!root1 && !root2) return true;\n\n// If only one of the roots is NULL, the trees are not identical\nif (!root1 || !root2) return false;\n\n// If the data of the current nodes is not equal, the trees are not identical\nif (root1->data != root2->data) return false;\n\n// Recursively check if the left subtrees and right subtrees are identical\nbool leftIdentical = identicalTrees(root1->left, root2->left);\nbool rightIdentical = identicalTrees(root1->right, root2->right);\n\n// Return true if both left and right subtrees are identical, otherwise false\nreturn leftIdentical && rightIdentical;\n}"
  },
  {
    "sign_no": 255,
    "question": "Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).",
    "name": "Zig Zag Traversal of Binary Tree",
    "topic": "bt",
    "level": "easy",
    "url": "https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/",
    "approach": "similer to level order traversal...but to traverse in zig zag we have to reverse the traversal alternately\nso we can store the level elements in a array similer to level order and take a flag which will define either we have \nto go to left to right or right to left....so now if flag is 1..means rigth to left then we reverse the array of that level then push to ans and update the flag every time.",
    "pseudo_code": "Function zigzagLevelOrder(root)\nInput: root - the root node of the binary tree\n\nOutput: a 2D vector representing the zigzag level order traversal of the binary tree\n\nIf root is null, return an empty vector\n\nInitialize an empty queue s\nPush root into the queue\nInitialize a flag to alternate the direction of traversal\nInitialize an empty 2D vector ans to store the result\n\nWhile the queue s is not empty:\nGet the size of the queue and store it in sz\nInitialize an empty vector temp to store the values of nodes at the current level\n\nFor i from 0 to sz - 1:\nDequeue the front element of the queue and store it in top\nIf top has a left child, enqueue it into the queue\nIf top has a right child, enqueue it into the queue\nAdd the value of top to the temp vector\n\nIf the flag is set:\nReverse the temp vector to alternate the direction of traversal\nReset the flag to 0\nElse:\nSet the flag to 1\n\nPush the temp vector into the ans vector\n\nReturn ans\nEnd Function"
  },
  {
    "sign_no": 256,
    "question": "You are given a binary tree having 'n' nodes.\n\n\nThe boundary nodes of a binary tree include the nodes from the left and right boundaries and the leaf nodes, each node considered once.\n\n\nFigure out the boundary nodes of this binary tree in an Anti-Clockwise direction starting from the root node.",
    "name": "Boundary Traversal of Binary Tree",
    "topic": "bt",
    "level": "medium",
    "url": "https://leetcode.com/problems/boundary-of-binary-tree/",
    "approach": "give tree ..we have to traverse the boundry..clock wise or anticock wise...\nto do it anti clock wise..\nwe first take the left most nodes..(excluding leaf) and then we taek the leaf nodes from left to right using preorder traversal\nthen we take the right most nodes similer way as left most excluding leaf...but right most should be in reverse order so we reverse the right most before inserting them to ans.",
    "pseudo_code": "Function isLeaf(root)\nInput: root - a pointer to a TreeNode<int> representing the root of a binary tree\n\nOutput: true if the root is a leaf node, false otherwise\n\nIf root has a left child or a right child, return false\nOtherwise, return true\nEnd Function\n\nFunction addLeft(root, ans)\nInput: root - a pointer to a TreeNode<int> representing the root of a binary tree\nans - a reference to a vector<int> to store the result\n\nOutput: None\n\nSet curr to the left child of root\nWhile curr is not null:\nIf curr is not a leaf node, add curr's data to ans\nIf curr has a left child, update curr to its left child\nOtherwise, update curr to its right child\nEnd Function\n\nFunction addRight(root, ans)\nInput: root - a pointer to a TreeNode<int> representing the root of a binary tree\nans - a reference to a vector<int> to store the result\n\nOutput: None\n\nSet curr to the right child of root\nInitialize an empty vector temp\nWhile curr is not null:\nIf curr is not a leaf node, add curr's data to temp\nIf curr has a right child, update curr to its right child\nOtherwise, update curr to its left child\nReverse temp and append its elements to ans\nEnd Function\n\nFunction addLeafs(root, ans)\nInput: root - a pointer to a TreeNode<int> representing the root of a binary tree\nans - a reference to a vector<int> to store the result\n\nOutput: None\n\nIf root is a leaf node, add its data to ans\nIf root has a left child, recursively call addLeafs with root's left child and ans\nIf root has a right child, recursively call addLeafs with root's right child and ans\nEnd Function\n\nFunction traverseBoundary(root)\nInput: root - a pointer to a TreeNode<int> representing the root of a binary tree\n\nOutput: a vector<int> representing the boundary traversal of the binary tree\n\nInitialize an empty vector ans\nIf root is null, return ans\nIf root is not a leaf node, add its data to ans\n\nCall addLeft with root and ans\nCall addLeafs with root and ans\nCall addRight with root and ans\n\nReturn ans\nEnd Function"
  },
  {
    "sign_no": 257,
    "question": "You are given a binary tree having 'n' nodes.\n\n\nVertical order traversal is a traversal in which we traverse the nodes from left to right and then from top to bottom.\n\n\nIn the case of multiple nodes in the same place, we traverse them in the non-decreasing order of their value.\n\n\nFormally, assume for any node at position (x, y), its left child will be at the position (x - 1, y + 1), and the right child at position (x + 1, y + 1). Assume the root is at coordinate (0, 0).\n\n\nRun vertical lines from 'x' = -infinity to 'x' = +infinity. Now whenever this vertical line touches some nodes, we need to add those values of the nodes in order starting from top to bottom with the decreasing 'y' coordinates.\n\n\nIf multiple nodes have the same 'x' and 'y' coordinates, they will be accessed in non-decreasing order of values.\n\n\nFind the vertical order traversal of the given tree.",
    "name": "Vertical Order Traversal of Binary Tree",
    "topic": "bt",
    "level": "easy",
    "url": "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/",
    "approach": "given tree..we know if we go left x decrease by 1 and if right x increase by 1, also y increase by 1 either we go right or left.\nso we can store this is a map data structire such that we can traverse the map from left to right on x axis...so our map's key will be x,\nnow for each x if two or more nodes have same x and y then we have to put the smaller one first...and to do that we have to use map as a value for main map..\n\nmap<int, map<int, multiset<int>>>;\nwe used multiset so we can store the duplicates also in sorted order.\n\nthen we can traverse the map -> map-> multset and insert the values to the ans array.",
    "pseudo_code": "Function traverse(root, x, y, mp)\nInput: root - a pointer to a TreeNode<int> representing the root of a binary tree\nx - the horizontal coordinate of the current node in the tree\ny - the vertical coordinate of the current node in the tree\nmp - a map of maps of multisets to store the nodes based on their coordinates\n\nOutput: None\n\nIf root is null, return\nInsert root's data into the multiset at coordinates (x, y) in mp\n\nRecursively call traverse with root's left child, x - 1, and y + 1\nRecursively call traverse with root's right child, x + 1, and y + 1\nEnd Function\n\nFunction verticalOrderTraversal(root)\nInput: root - a pointer to a TreeNode<int> representing the root of a binary tree\n\nOutput: a vector<int> representing the vertical order traversal of the binary tree\n\nInitialize an empty map of maps of multisets mp\nInitialize an empty vector ans\n\nCall traverse with root, 0, 0, and mp\n\nIterate over each pair (x, map<int, multiset<int>> y) in mp:\nIterate over each pair (y, multiset<int> val) in y:\nIterate over each value val in the multiset:\nAppend val to ans\nReturn ans\nEnd Function"
  },
  {
    "sign_no": 258,
    "question": "You are given a Binary Tree of 'n' nodes.\n\n\nThe Top view of the binary tree is the set of nodes visible when we see the tree from the top.\n\n\nFind the top view of the given binary tree, from left to right.",
    "name": "Top View of Binary Tree",
    "topic": "bt",
    "level": "easy",
    "url": "https://practice.geeksforgeeks.org/problems/top-view-of-binary-tree/1",
    "approach": "similer to prev problem....but here we have to take the node that is on highest level at that x point...\nmeans if there are more nodes at same x then we have to take one which has lowest y so if the tree is viewed from top we will see those...",
    "pseudo_code": "Function traverse(root, x, y, mp)\nInput: root - a pointer to a TreeNode<int> representing the root of a binary tree\nx - the horizontal coordinate of the current node in the tree\ny - the vertical coordinate of the current node in the tree\nmp - a map of horizontal coordinates to pairs representing vertical coordinate and node value\n\nOutput: None\n\nIf root is null, return\nIf mp contains x:\nIf mp[x].first is greater than y:\nUpdate mp[x] with (y, root->data)\nElse:\nInsert (x, (y, root->data)) into mp\n\nRecursively call traverse with root's left child, x - 1, and y + 1\nRecursively call traverse with root's right child, x + 1, and y + 1\nEnd Function\n\nFunction getTopView(root)\nInput: root - a pointer to a TreeNode<int> representing the root of a binary tree\n\nOutput: a vector<int> representing the top view of the binary tree\n\nInitialize an empty vector ans\nInitialize an empty map mp\n\nCall traverse with root, 0, 0, and mp\n\nIterate over each pair (x, pair<int, int> val) in mp:\nAppend val.second (the node value) to ans\nReturn ans\nEnd Function"
  },
  {
    "sign_no": 259,
    "question": "You are given a 'Binary Tree'.\n\n\nReturn the bottom view of the binary tree.\n\n\nNote :\n\n1. A node will be in the bottom-view if it is the bottom-most node at its horizontal distance from the root. \n\n2. The horizontal distance of the root from itself is 0. The horizontal distance of the right child of the root node is 1 and the horizontal distance of the left child of the root node is -1. \n\n3. The horizontal distance of node 'n' from root = horizontal distance of its parent from root + 1, if node 'n' is the right child of its parent.\n\n4. The horizontal distance of node 'n' from root = horizontal distance of its parent from the root - 1, if node 'n' is the left child of its parent.\n\n5. If more than one node is at the same horizontal distance and is the bottom-most node for that horizontal distance, including the one which is more towards the right.",
    "name": "Bottom View of Binary Tree",
    "topic": "bt",
    "level": "medium",
    "url": "https://practice.geeksforgeeks.org/problems/bottom-view-of-binary-tree/1",
    "approach": "similer to top view problem...\nhere if x are same then take greater y, and if y is also same then take the right one...which is taken care of as we are doing preorder traversal.",
    "pseudo_code": "Function traverse(root, x, y, mp)\nInput: root - a pointer to a TreeNode<int> representing the root of a binary tree\nx - the horizontal coordinate of the current node in the tree\ny - the vertical coordinate of the current node in the tree\nmp - a map of horizontal coordinates to pairs representing vertical coordinate and node value\n\nOutput: None\n\nIf root is null, return\nIf mp contains x:\nIf mp[x].first is less than y:\nUpdate mp[x] with (y, root->data)\nElse if mp[x].first is equal to y:\nUpdate mp[x].second with root->data\nElse:\nInsert (x, (y, root->data)) into mp\n\nRecursively call traverse with root's left child, x - 1, and y + 1\nRecursively call traverse with root's right child, x + 1, and y + 1\nEnd Function\n\nFunction bottomView(root)\nInput: root - a pointer to a TreeNode<int> representing the root of a binary tree\n\nOutput: a vector<int> representing the bottom view of the binary tree\n\nInitialize an empty vector ans\nIf root is null, return ans\n\nInitialize an empty map mp\nCall traverse with root, 0, 0, and mp\n\nIterate over each pair (x, pair<int, int> val) in mp:\nAppend val.second (the node value) to ans\nReturn ans\nEnd Function"
  },
  {
    "sign_no": 260,
    "question": "You have been given a Binary Tree of 'n' nodes, where the nodes have integer values\n\n\nPrint the left view of the binary tree.",
    "name": "Right/Left View of Binary Tree",
    "topic": "bt",
    "level": "medium",
    "url": "https://leetcode.com/problems/binary-tree-right-side-view/",
    "approach": "similer to prev problem..can be solved using map and also without using map...\nwe just have to traverse the tree in preorder and for each node..check if there is already a current level present in map...if not then push it to map if yes then do nothing and keep traversing....\n\n\n\nto do it without map...we can have a extra var that will store the max level till now...and while traversing if we get to a node with more level then max then its the left most node at that level so we can put it in our ans..",
    "pseudo_code": "Function traverse(root, level, maxLevel, ans)\nInput: root - a pointer to a BinaryTreeNode<int> representing the root of a binary tree\nlevel - the current level of the node in the tree\nmaxLevel - the maximum level encountered so far during traversal\nans - a reference to a vector<int> to store the left view of the binary tree\n\nOutput: None\n\nIf root is null, return\nIf level is greater than maxLevel:\nAppend root's data to ans\nUpdate maxLevel with level\nRecursively call traverse with root's left child, level + 1, maxLevel, and ans\nRecursively call traverse with root's right child, level + 1, maxLevel, and ans\nEnd Function\n\nFunction printLeftView(root)\nInput: root - a pointer to a BinaryTreeNode<int> representing the root of a binary tree\n\nOutput: a vector<int> representing the left view of the binary tree\n\nInitialize an empty vector ans\nInitialize maxLevel to 0\nCall traverse with root, 1, maxLevel, and ans\n\nReturn ans\nEnd Function"
  },
  {
    "sign_no": 261,
    "question": "You have been given a Binary Tree having 'n' nodes.\n\n\nA Symmetric tree is a binary tree whose mirror image is the same as the original tree.\n\n\nFind out whether the given tree is symmetric or not.",
    "name": "Symmetric Binary Tree",
    "topic": "bt",
    "level": "medium",
    "url": "https://leetcode.com/problems/symmetric-tree/",
    "approach": "to check for symmetry of a tree..\nwe can compare it to same tree but in opposite direction..means we will check for left in one and right in second ..then compare both...\nif both are not same then our tree is not symetric...else at the end if not returned false then we can return true",
    "pseudo_code": "Function checkForSymmetry(root1, root2)\nInput: root1 - a pointer to a TreeNode<int> representing the root of the first binary tree\nroot2 - a pointer to a TreeNode<int> representing the root of the second binary tree\n\nOutput: true if the two trees are symmetric, false otherwise\n\nIf both root1 and root2 are null, return true (base case for empty trees)\nIf either root1 or root2 is null (but not both), return false (base case for asymmetric trees)\n\nIf the data of root1 is not equal to the data of root2, return false\n\nRecursively call checkForSymmetry with root1's left child and root2's right child\nRecursively call checkForSymmetry with root1's right child and root2's left child\n\nIf any of the recursive calls return false, return false\n\nReturn true if all checks pass, indicating symmetry\nEnd Function\n\nFunction isSymmetric(root)\nInput: root - a pointer to a TreeNode<int> representing the root of a binary tree\n\nOutput: true if the binary tree is symmetric, false otherwise\n\nInitialize two pointers head1 and head2 to root\n\nCall checkForSymmetry with head1 and head2\n\nReturn the result of checkForSymmetry\nEnd Function"
  },
  {
    "sign_no": 262,
    "question": "You are given an arbitrary binary tree consisting of 'N' nodes numbered from 1 to 'N'. Your task is to print all the root to leaf paths of the binary tree.\n\nA leaf of a binary tree is the node which does not have a left child and a right child.",
    "name": "Root to Node Path in Binary Tree",
    "topic": "bt",
    "level": "medium",
    "url": "https://bit.ly/3QA600D",
    "approach": "to find all the paths we can traverse the tree using any traversal method like inorder, pre, or post..\nthen we can have a base case that if a node is leaf node then push the string to ans vector...\nas now our root will never be null so we can just add the current data to our string...after conversion from int to string.\n\nthen if left go to left if right go to right....",
    "pseudo_code": "Function isLeaf(root)\nInput: root - a pointer to a BinaryTreeNode<int> representing the node to be checked\n\nOutput: true if root is a leaf node (i.e., it has no left or right children), false otherwise\n\nIf root has no left child and no right child, return true\nOtherwise, return false\nEnd Function\n\nFunction traverse(root, temp, ans)\nInput: root - a pointer to a BinaryTreeNode<int> representing the current node in the traversal\ntemp - a string representing the current path from the root to the current node\nans - a reference to a vector<string> to store the paths from the root to leaf nodes\n\nOutput: None\n\nIf temp is not empty, append root's data to temp separated by a space; otherwise, set temp to root's data as a string\nIf root is a leaf node:\nAppend temp to ans\nReturn\nIf root has a left child, recursively call traverse with root's left child, temp, and ans\nIf root has a right child, recursively call traverse with root's right child, temp, and ans\nEnd Function\n\nFunction allRootToLeaf(root)\nInput: root - a pointer to a BinaryTreeNode<int> representing the root of the binary tree\n\nOutput: a vector<string> representing all root-to-leaf paths in the binary tree\n\nIf root is null, return an empty vector\n\nInitialize an empty vector ans\nCall traverse with root, an empty string as temp, and ans\n\nReturn ans\nEnd Function"
  },
  {
    "sign_no": 263,
    "question": "You have been given a Binary Tree of integers. You are supposed to return the maximum width of the given Binary Tree. The maximum width of the tree is the maximum width among all the levels of the given tree.\n\n\nThe width of one level is defined as the length between the leftmost and the rightmost, non-null nodes in the level, where the null nodes in between the leftmost and rightmost are excluded into length calculation.",
    "name": "LCA in Binary Tree",
    "topic": "bt",
    "level": "medium",
    "url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/",
    "approach": "to calculate the witdh of the binary tree we can traverse the tree using preorder and for each level we can store the count of nodes on that level in a map...and the max count will be our ans.",
    "pseudo_code": "Function traverse(root, lvl, mp)\nInput: root - a pointer to a TreeNode<int> representing the root of the binary tree\nlvl - the current level of the node in the tree\nmp - an unordered_map<int, int> representing the mapping of levels to their widths\n\nOutput: None\n\nIf root is null, return\nIncrement mp[lvl] to count the number of nodes at the current level\n\nRecursively call traverse with root's left child, lvl + 1, and mp\nRecursively call traverse with root's right child, lvl + 1, and mp\nEnd Function\n\nFunction getMaxWidth(root)\nInput: root - a pointer to a TreeNode<int> representing the root of the binary tree\n\nOutput: an integer representing the maximum width of the binary tree\n\nIf root is null, return 0\n\nInitialize an empty unordered_map mp to store the widths of each level\n\nCall traverse with root, 1, and mp to populate mp with level widths\nInitialize ans to 0\n\nIterate over each pair (level, width) in mp:\nUpdate ans to the maximum value between ans and width\n\nReturn ans as the maximum width of the binary tree\nEnd Function"
  },
  {
    "sign_no": 264,
    "question": "You have been given a Binary Tree of distinct integers and two nodes ‘X’ and ‘Y’. You are supposed to return the LCA (Lowest Common Ancestor) of ‘X’ and ‘Y’.\n\n\nThe LCA of ‘X’ and ‘Y’ in the binary tree is the shared ancestor of ‘X’ and ‘Y’ that is located farthest from the root.\n\n\nNote :\n\nYou may assume that given ‘X’ and ‘Y’ definitely exist in the given binary tree.",
    "name": "Maximum width of a Binary Tree",
    "topic": "bt",
    "level": "medium",
    "url": "https://leetcode.com/problems/maximum-width-of-binary-tree/",
    "approach": "to find out the lca we can use this two techniques.\n1. find the path of each node and compare them...the last element that is common in both paths will be our ancestor.\n\n2. we can use dfs traversal like preorder...and follow some conditions..if we find the node that has value equal to any of the x xor y then return that node, if root is null return null\nnow as we are finding the common ancestor so we go for left and right..store the nodes or null valules returned by left or right, \nif both left and right are not null that means we found both the nodes x and y and the node that has left and right not null is the LCA so we return the root, if only one of them is null, either left or right then return the not null one, and if both are null then return null.\n\nat the end we will return the node that is LCA of given two nodes.",
    "pseudo_code": "Function traverse(root, x, y)\nInput: root - a pointer to a TreeNode<int> representing the root of the binary tree\nx - an integer representing the value of the first node to find\ny - an integer representing the value of the second node to find\n\nOutput: a pointer to a TreeNode<int> representing the lowest common ancestor of nodes with values x and y\n\nIf root is null, return nullptr\n\nIf root's data is equal to x or y, return root (either x or y found)\n\nRecursively call traverse with root's left child, x, and y, and assign the result to ln\nRecursively call traverse with root's right child, x, and y, and assign the result to rn\n\nIf ln and rn are not null, return root (both x and y found in different subtrees)\nIf ln is not null, return ln (either x or y found in the left subtree)\nIf rn is not null, return rn (either x or y found in the right subtree)\n\nOtherwise, return nullptr (neither x nor y found in the subtree rooted at root)\nEnd Function\n\nFunction lowestCommonAncestor(root, x, y)\nInput: root - a pointer to a TreeNode<int> representing the root of the binary tree\nx - an integer representing the value of the first node\ny - an integer representing the value of the second node\n\nOutput: an integer representing the value of the lowest common ancestor of nodes with values x and y\n\nReturn the data of the node returned by traverse(root, x, y)\nEnd Function"
  },
  {
    "sign_no": 265,
    "question": "Return true if all non-leaf nodes in a given binary tree have a value that is equal to the sum of their child nodes, otherwise return false..",
    "name": "Check for Children Sum Property",
    "topic": "bt",
    "level": "hard",
    "url": "https://bit.ly/3dEr73g",
    "approach": "we can iterate all the nodes using any traversal method...\nthen for each node we can check if its leaf node that means there is no child so return true\nif its not leaf node and not either null then take sum of its left and right child and check if its not equal return false,\nthen go to left and right and return left && right...as there should be no false then only our ans will be true.",
    "pseudo_code": "Function isLeaf(root)\nInput: root - a pointer to a Node representing the node to be checked\n\nOutput: true if root is a leaf node (i.e., it has no left or right children), false otherwise\n\nIf root has no left child and no right child, return true\nOtherwise, return false\nEnd Function\n\nFunction isParentSum(root)\nInput: root - a pointer to a Node representing the root of a binary tree\n\nOutput: true if the binary tree satisfies the parent sum property, false otherwise\n\nIf root is null, return true (empty tree is considered to satisfy the parent sum property)\nIf root is a leaf node, return true (leaf nodes are considered to satisfy the parent sum property)\n\nInitialize sum to 0\nIf root has a left child, add its data to sum\nIf root has a right child, add its data to sum\n\nIf sum is not equal to root's data, return false (parent sum property is violated)\n\nRecursively call isParentSum with root's left child and assign the result to l\nRecursively call isParentSum with root's right child and assign the result to r\n\nReturn true if both l and r are true, indicating that both subtrees satisfy the parent sum property\nEnd Function"
  },
  {
    "sign_no": 266,
    "question": "You are given an arbitrary binary tree, a node of the tree, and an integer 'K'. You need to find all such nodes which have a distance K from the given node and return the list of these nodes.\n\n\nDistance between two nodes in a binary tree is defined as the number of connections/edges in the path between the two nodes.\n\n\nNote:\n\n1. A binary tree is a tree in which each node has at most two children. \n2. The given tree will be non-empty.\n3. The given tree can have multiple nodes with the same value.\n4. If there are no nodes in the tree which are at distance = K from the given node, return an empty list.\n5. You can return the list of values of valid nodes in any order. For example if the valid nodes have values 1,2,3, then you can return {1,2,3} or {3,1,2} etc.",
    "name": "Print all the Nodes at a distance of K in a Binary Tree",
    "topic": "bt",
    "level": "medium",
    "url": "https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/",
    "approach": "to find all the elements with distance k from given node we have to go to left, right and top of that given node ,\nwe can go to left and right child but we can't go to parent..and to do that we have an map to store the parent of each node,\nthen we can just use the level order traveral technique to traverse ech node present in queue at that level, level will be our distance here and we start level with 0 and if level becomes K then all the nodes present in the queue at that time will be our ans,\nas we have to find k nodes..but we can not go to same node again and again so we check for visited, store all the visited nodesi in a other map.\nthen take all the nodes from queue to array or vector.",
    "pseudo_code": "Function markParents(root, parent)\nInput: root - a pointer to a BinaryTreeNode<int> representing the root of the binary tree\nparent - an unordered_map<BinaryTreeNode<int>*, BinaryTreeNode<int>*> representing the mapping of child nodes to their parents\n\nOutput: None\n\nIf root is null, return\nIf root has a left child, add root as the parent of root's left child in the parent map and recursively call markParents with root's left child and parent\nIf root has a right child, add root as the parent of root's right child in the parent map and recursively call markParents with root's right child and parent\nEnd Function\n\nFunction printNodesAtDistanceK(root, target, k)\nInput: root - a pointer to a BinaryTreeNode<int> representing the root of the binary tree\ntarget - a pointer to a BinaryTreeNode<int> representing the target node\nk - an integer representing the distance from the target node to print nodes\n\nOutput: a vector<BinaryTreeNode<int>*> representing the nodes at distance k from the target node\n\nInitialize an empty unordered_map parent to store the parent nodes\nCall markParents with root and parent to populate the parent map\n\nInitialize an empty unordered_map visited to track visited nodes\nInitialize an empty queue q to perform level-order traversal\nPush the target node into the queue q\nMark the target node as visited in the visited map\nInitialize a variable lvl to 0 to track the current level\n\nWhile q is not empty:\nGet the size of the queue sz\nIf lvl equals k, break the loop\n\nIterate over each node in the current level:\nPop the front node from the queue and assign it to top\nIf top has a left child and the left child has not been visited:\nPush the left child into the queue\nMark the left child as visited in the visited map\nIf top has a right child and the right child has not been visited:\nPush the right child into the queue\nMark the right child as visited in the visited map\nIf top has a parent and the parent has not been visited:\nPush the parent into the queue\nMark the parent as visited in the visited map\n\nIncrement lvl by 1\n\nInitialize an empty vector ans to store the nodes at distance k\nWhile q is not empty:\nPush the front node from the queue into the ans vector\nPop the front node from the queue\n\nReturn ans as the result\nEnd Function"
  },
  {
    "sign_no": 267,
    "question": "You have a binary tree of 'N' unique nodes and a Start node from where the tree will start to burn. Given that the Start node will always exist in the tree, your task is to print the time (in minutes) that it will take to burn the whole tree.\n\n\nIt is given that it takes 1 minute for the fire to travel from the burning node to its adjacent node and burn down the adjacent node.",
    "name": "Minimum time taken to BURN the Binary Tree from a Node",
    "topic": "bt",
    "level": "hard",
    "url": "https://bit.ly/3wcg7k1",
    "approach": "similer to previous problem...here we have to go to left right and top as prev prob, but we have to go till all nodes get visited, means we have to go to the farthest level or distance from the given node, and the farthest distance-1 will be our ans as the given node will burn in 0th min, also distance or lvl start from 0, and if the traget node is not given instead value is given then have to find that node so we can traverse accordingly.",
    "pseudo_code": "Function markParent(root, mp)\nInput: root - a pointer to a BinaryTreeNode<int> representing the root of the binary tree\nmp - an unordered_map<BinaryTreeNode<int>*, BinaryTreeNode<int>*> representing the mapping of child nodes to their parents\n\nOutput: None\n\nIf root is null, return\nIf root has a left child, add root as the parent of root's left child in the mp map and recursively call markParent with root's left child and mp\nIf root has a right child, add root as the parent of root's right child in the mp map and recursively call markParent with root's right child and mp\nEnd Function\n\nFunction findStart(root, start)\nInput: root - a pointer to a BinaryTreeNode<int> representing the root of the binary tree\nstart - an integer representing the value to find in the binary tree\n\nOutput: a pointer to a BinaryTreeNode<int> representing the node with value start, or null if not found\n\nIf root is null, return null\nIf root's data is equal to start, return root\n\nRecursively call findStart with root's left child and start, and assign the result to ln\nIf ln is not null, return ln\n\nRecursively call findStart with root's right child and start, and assign the result to rn\nIf rn is not null, return rn\n\nOtherwise, return null\nEnd Function\n\nFunction timeToBurnTree(root, start)\nInput: root - a pointer to a BinaryTreeNode<int> representing the root of the binary tree\nstart - an integer representing the value of the node from which the tree starts burning\n\nOutput: an integer representing the time taken for the entire tree to burn from the start node\n\nInitialize an empty unordered_map parent to store the parent nodes\nCall markParent with root and parent to populate the parent map\n\nFind the start node in the binary tree using findStart with root and start\n\nInitialize lvl to 0 to track the current level\nInitialize an empty queue q to perform level-order traversal\nInitialize an empty unordered_map visited to track visited nodes\n\nPush the start node into the queue q\nMark the start node as visited in the visited map\n\nWhile q is not empty:\nGet the size of the queue sz\nIncrement lvl by 1\n\nIterate over each node in the current level:\nPop the front node from the queue and assign it to top\nIf top has a left child and the left child has not been visited:\nPush the left child into the queue\nMark the left child as visited in the visited map\nIf top has a right child and the right child has not been visited:\nPush the right child into the queue\nMark the right child as visited in the visited map\nIf top has a parent and the parent has not been visited:\nPush the parent into the queue\nMark the parent as visited in the visited map\n\nReturn lvl - 1 as the time taken for the entire tree to burn\nEnd Function"
  },
  {
    "sign_no": 268,
    "question": "You are given the root of a complete binary tree, you need to calculate the number of nodes in the given complete binary tree.\n\nA complete binary tree is a tree in which all the levels are completely filled except the last level. Nodes in the last level are as left as possible.",
    "name": "Count total Nodes in a COMPLETE Binary Tree",
    "topic": "bt",
    "level": "medium",
    "url": "https://leetcode.com/problems/count-complete-tree-nodes/",
    "approach": "we can count nodes easily but it will take o(n) TC,\nbut we have to do it in logN TC and to do that we use the property of complete binary tree,\na tree can have max 2^h - 1 nodes, h is the height, \nso for root we check for left height and right height if both are same that means that tree is fully filled so we can return the max nodes for its height, \nif not equal then we can go to left and right childs using recursion then follow the same for them,as our function is returning the number of nodes, so we have to return the number of nodes on left + right + 1;",
    "pseudo_code": "Function calculateLeftHeight(root)\nInput: root - a pointer to a BinaryTreeNode<int> representing the root of a binary tree\n\nOutput: an integer representing the height of the left subtree rooted at root\n\nInitialize height to 0\nWhile root is not null:\nIncrement height by 1\nUpdate root to root's left child\n\nReturn height\nEnd Function\n\nFunction calculateRightHeight(root)\nInput: root - a pointer to a BinaryTreeNode<int> representing the root of a binary tree\n\nOutput: an integer representing the height of the right subtree rooted at root\n\nInitialize height to 0\nWhile root is not null:\nIncrement height by 1\nUpdate root to root's right child\n\nReturn height\nEnd Function\n\nFunction countNodes(root)\nInput: root - a pointer to a BinaryTreeNode<int> representing the root of a binary tree\n\nOutput: an integer representing the total number of nodes in the binary tree rooted at root\n\nIf root is null, return 0\n\nCalculate the height of the left subtree rooted at root using calculateLeftHeight and assign it to lh\nCalculate the height of the right subtree rooted at root using calculateRightHeight and assign it to rh\n\nIf lh is equal to rh (i.e., the left and right subtrees have the same height):\nReturn the total number of nodes in the perfect binary tree with height lh, which is (2^lh) - 1\n\nOtherwise, recursively count the number of nodes in the left subtree rooted at root's left child and assign it to left\nRecursively count the number of nodes in the right subtree rooted at root's right child and assign it to right\n\nReturn the total number of nodes in the binary tree rooted at root, which is left + right + 1\nEnd Function"
  },
  {
    "sign_no": 269,
    "question": "Given a pair of tree traversal, return 'true' if a unique binary tree can be constructed otherwise 'false'.\n\n\nNote:\n\nEach traversal is represented with an integer: preorder - 1, inorder - 2, postorder - 3. ",
    "name": "Requirements needed to construct a Unique Binary Tree | Theory",
    "topic": "bt",
    "level": "medium",
    "url": "https://bit.ly/3UVCR1U",
    "approach": "we can't make a unique tree if both a and be are same or one is preorder and 1 is postorder.",
    "pseudo_code": "-"
  },
  {
    "sign_no": 270,
    "question": "You have been given the preorder and inorder traversal of a binary tree. Your task is to construct a binary tree using the given inorder and preorder traversals.\n\n\nNote:\n\nYou may assume that duplicates do not exist in the given traversals.",
    "name": "Construct Binary Tree from inorder and preorder",
    "topic": "bt",
    "level": "hard",
    "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/",
    "approach": "we have inorder and preorder traversals...\n\nso we know that the preorder's 1st element tell us the root, now we can find the root in inorder and the left element of root in inorder will be left sub tree parts and right will be right subtree parts.\nso we have divider the problem in smaller parts such that we can solve the problem for left subtree part of inorder such that the number of elemet in that part will be the number of element in preorder from start+1 to that number which will tell us the roots.\nby following this and dividing the problem in smaller parts we can solve the problem",
    "pseudo_code": "Function helper(preorder, preStart, preEnd, inorder, inStart, inEnd, inmap)\nInput: preorder - a vector of integers representing the preorder traversal of the binary tree\npreStart - an integer representing the starting index of the current subtree in the preorder traversal\npreEnd - an integer representing the ending index of the current subtree in the preorder traversal\ninorder - a vector of integers representing the inorder traversal of the binary tree\ninStart - an integer representing the starting index of the current subtree in the inorder traversal\ninEnd - an integer representing the ending index of the current subtree in the inorder traversal\ninmap - a map containing the indices of elements in the inorder traversal\n\nOutput: a TreeNode pointer representing the root of the constructed binary tree\n\nIf preStart is greater than preEnd or inStart is greater than inEnd:\nReturn NULL (base case: empty subtree)\n\nCreate a new TreeNode with the value of preorder[preStart] as the root\nFind the index of the root in the inorder traversal (inRoot)\n\nCalculate the number of nodes in the left subtree (numsLeft) as (inRoot - inStart)\n\nRecursively call helper to construct the left subtree:\nSet the left child of the root to the result of helper with updated parameters:\n- preorder\n- preStart + 1\n- preStart + numsLeft\n- inorder\n- inStart\n- inRoot - 1\n- inmap\n\nRecursively call helper to construct the right subtree:\nSet the right child of the root to the result of helper with updated parameters:\n- preorder\n- preStart + numsLeft + 1\n- preEnd\n- inorder\n- inRoot + 1\n- inEnd\n- inmap\n\nReturn the root\n\nEnd Function\n\nFunction buildBinaryTree(inorder, preorder)\nInput: inorder - a vector of integers representing the inorder traversal of the binary tree\npreorder - a vector of integers representing the preorder traversal of the binary tree\n\nOutput: a TreeNode pointer representing the root of the constructed binary tree\n\nInitialize an empty map inmap to store the indices of elements in the inorder traversal\n\nFor each element and index in inorder:\nAdd a key-value pair to inmap with the element as the key and the index as the value\n\nCall helper with the initial parameters:\n- preorder\n- 0\n- size of preorder - 1\n- inorder\n- 0\n- size of inorder - 1\n- inmap\n\nReturn the root of the constructed binary tree\n\nEnd Function"
  },
  {
    "sign_no": 271,
    "question": "You are given arrays 'inOrder' and 'postOrder', which represent 'inorder' traversal and 'postorder' traversal of a 'Binary Tree' respectively.\n\n\nConstruct a 'Binary Tree' represented by the given arrays and return it's head.\n\n\nNote:\n\nAssume that the Binary Tree contains only unique elements.",
    "name": "Construct the Binary Tree from Postorder and Inorder Traversal",
    "topic": "bt",
    "level": "hard",
    "url": "https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/",
    "approach": "similer to previous problem.....here we have postorder instead of preorder and we know the last element of postorder is the root element so we can go right to left on post order and go right on in order first then the remaining in postorder will be left of inorder.",
    "pseudo_code": "FUNCTION getTreeFromPostorderAndInorder(postOrder, inOrder):\ninMap = an empty map\nFOR i = 0 to length(inOrder) - 1:\ninMap[inOrder[i]] = i\nEND FOR\n\nroot = helper(postOrder, length(postOrder) - 1, 0, inOrder, 0, length(inOrder) - 1, inMap)\nRETURN root\n\nFUNCTION helper(postorder, postStart, postEnd, inorder, inStart, inEnd, inMap):\nIF postStart > postEnd OR inStart > inEnd:\nRETURN NULL\n\nroot = CREATE NEW TreeNode WITH VALUE postorder[postStart]\ninRoot = inMap[root.data]\nleftNums = inEnd - inRoot\n\nroot.right = helper(postorder, postStart - 1, postStart - leftNums, inorder, inRoot + 1, inEnd, inMap)\nroot.left = helper(postorder, postStart - leftNums - 1, postEnd, inorder, inStart, inRoot - 1, inMap)\n\nRETURN root"
  },
  {
    "sign_no": 272,
    "question": "You have been given a binary tree of integers. You are supposed to serialize and deserialize (refer to notes) the given binary tree.\n\n\nYou can choose any algorithm to serialize/deserialize the given binary tree. You only have to ensure that the serialized string can be deserialized to the original binary tree.\n\n\nNote :\n\nSerialization is the process of translating a data structure or object state into a format that can be stored or transmitted (for example, across a computer network) and reconstructed later. The opposite operation, that is, extracting a data structure from stored information, is deserialization.",
    "name": "Serialize and deserialize Binary Tree",
    "topic": "bt",
    "level": "hard",
    "url": "https://leetcode.com/problems/serialize-and-deserialize-binary-tree/",
    "approach": "serialization is easy as we just have to use level order traversal and make a string from that.\n\nhowever for deserialization we can not convert it directly..as we have to find out which child is null and the string containes spaces too..\nso to handle it we use stringstream and ' 'space char as delimeter while traversing the string for each present in the queue and adding new nodese to tree and pushing them to q for further iteration.",
    "pseudo_code": "FUNCTION serializeTree(root):\nCREATE an empty queue q\nPUSH root to q\nans = an empty string\n\nWHILE q is not empty:\nsz = size of q\nFOR i = 0 to sz - 1:\nfront = q.front()\nq.pop()\nIF front is NULL:\nappend \"-1 \" to ans\nELSE:\nappend front.data + \" \" to ans\nIF front is not NULL:\nPUSH front.left to q\nPUSH front.right to q\nRETURN ans\n\nFUNCTION deserializeTree(data):\nn = length of data\nIF n is 0:\nRETURN NULL\n\nCREATE a stringstream s with data\nREAD a string str from s\nroot = CREATE NEW TreeNode WITH VALUE str\nCREATE an empty queue q\nPUSH root to q\n\nWHILE q is not empty:\nnode = q.front()\nq.pop()\nREAD a string str from s\nIF str is \"-1\":\nnode.left = NULL\nELSE:\nleftNode = CREATE NEW TreeNode WITH VALUE str\nnode.left = leftNode\nPUSH leftNode to q\n\nREAD a string str from s\nIF str is \"-1\":\nnode.right = NULL\nELSE:\nrightNode = CREATE NEW TreeNode WITH VALUE str\nnode.right = rightNode\nPUSH rightNode to q\n\nRETURN root"
  },
  {
    "sign_no": 273,
    "question": "Inorder traversal using morris traversal method",
    "name": "Morris Preorder Traversal of a Binary Tree",
    "topic": "bt",
    "level": "medium",
    "url": "https://leetcode.com/problems/binary-tree-inorder-traversal/",
    "approach": "The main benifit of morris traversal is reducing the space used\n\nwe use threaded binray tree concept for implement the traversal\n\nbasically we connect the right most node of the left sub tree to the root, as in inorder traversal the sequence is like that. so there are 2 cases...if root->left is null that means that we have to print the root , and if there is a left child then we will go to the right most node of that left child and see if there is a thread , if yes then break the thread, print the root(current) and move the root to right, if threre is no theread then make one and move the curr to left node.",
    "pseudo_code": "FUNCTION getInOrderTraversal(root):\ninorder = an empty vector\ncurr = root\n\nWHILE curr is not NULL:\nIF curr.left is NULL:\nappend curr.data to inorder\ncurr = curr.right\nELSE:\nprev = curr.left\nWHILE prev.right is not NULL AND prev.right is not curr:\nprev = prev.right\nIF prev.right is NULL:\nprev.right = curr\ncurr = curr.left\nELSE:\nprev.right = NULL\nappend curr.data to inorder\ncurr = curr.right\n\nRETURN inorder"
  },
  {
    "sign_no": 274,
    "question": "preorder traversal using morris traversal method",
    "name": "Morris Inorder Traversal of a Binary Tree",
    "topic": "bt",
    "level": "medium",
    "url": "https://leetcode.com/problems/binary-tree-inorder-traversal/",
    "approach": "same as prev, just a change of single line\n\nas whene inserting the curr at last , we will insert it before moving to left such that it will follow the preorder method",
    "pseudo_code": "FUNCTION preOrder(root):\ncur = root\npreorder = an empty vector\n\nWHILE cur is not NULL:\nIF cur.left is NULL:\nappend cur.data to preorder\ncur = cur.right\nELSE:\nprev = cur.left\nWHILE prev.right is not NULL AND prev.right is not cur:\nprev = prev.right\nIF prev.right is cur:\nprev.right = NULL\ncur = cur.right\nELSE:\nappend cur.data to preorder\nprev.right = cur\ncur = cur.left\n\nRETURN preorder"
  },
  {
    "sign_no": 275,
    "question": "You are given a binary tree consisting of 'n' nodes.\n\n\nConvert the given binary tree into a linked list where the linked list nodes follow the same order as the pre-order traversal of the given binary tree.\n\n\nUse the right pointer of the binary tree as the “next” pointer for the linked list and set the left pointer to NULL.\n\n\nUse these nodes only. Do not create extra nodes.",
    "name": "Flatten Binary Tree to LinkedList",
    "topic": "bt",
    "level": "hard",
    "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/",
    "approach": "To flatten the binary tree and convert it to linked list as the given condiion of preorder traversal, \nwe can do one thing...take the root and make its left null and put left to right...so now one this will get missing , the old right of the node...however we can do this question using recursion by going to right then left then root , making the connection from reverse as given in the 1st pseudo code.\n\n2. we can do this using the iterative method using the stack datat structure, using the concept of traversal we will push the right then left to the stack as making the reverse connections (check the 2nd pseudo code)",
    "pseudo_code": "1. Recursive.\nGLOBAL prevNode = NULL\n\nFUNCTION helper(root):\nIF root is NULL:\nRETURN\n\nhelper(root.right)\nhelper(root.left)\n\nroot.right = prevNode\nroot.left = NULL\nprevNode = root\n\nFUNCTION flattenBinaryTree(root):\nhelper(root)\n\n\n\n2. Iterative.\n\n\nFUNCTION flattenBinaryTree(root):\nCREATE an empty stack st\nPUSH root to st\n\nWHILE st is not empty:\ntop = st.top()\nst.pop()\n\nIF top.right is not NULL:\nPUSH top.right to st\n\nIF top.left is not NULL:\nPUSH top.left to st\n\nIF st is not empty:\ntop.right = st.top()\n\ntop.left = NULL"
  },
  {
    "sign_no": 276,
    "question": "You are given an array ‘order’ which represents the inorder traversal of a binary search tree.\n\n\nFind out if this traversal is valid or not.\n\n\nNote: All values in the BST must be unique.",
    "name": "Introduction to Binary Search Tree",
    "topic": "bst",
    "level": "easy",
    "url": "https://bit.ly/3gprRLk",
    "approach": "For a inorder traversal array to be BST it should be sorted, and the condition given in the questino says that there should not be any duplicates. so inorder traversal has to be sorted and without duplicartes is a proper BST,\n\nso we can check out each elemetn and compare it with i+1 if its greater or equal then return false....at end return true.",
    "pseudo_code": ""
  },
  {
    "sign_no": 277,
    "question": "You are given the root of a binary search tree (BST) and an integer val.\n\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.",
    "name": "Search in a Binary Search Tree",
    "topic": "bst",
    "level": "easy",
    "url": "https://leetcode.com/problems/search-in-a-binary-search-tree/",
    "approach": "",
    "pseudo_code": ""
  },
  {
    "sign_no": 278,
    "question": "find min or max of BST",
    "name": "Find Min/Max in BST",
    "topic": "bst",
    "level": "medium",
    "url": "https://practice.geeksforgeeks.org/problems/minimum-element-in-bst/1",
    "approach": "left most is min, right most is max",
    "pseudo_code": ""
  },
  {
    "sign_no": 279,
    "question": "Ninja is given a binary search tree and an integer. Now he is given a particular key in the tree and returns its ceil value. Can you help Ninja solve the problem?\nNote:\n\nCeil of an integer is the closest integer greater than or equal to a given number.",
    "name": "Ceil in a Binary Search Tree",
    "topic": "bst",
    "level": "easy",
    "url": "https://practice.geeksforgeeks.org/problems/implementing-ceil-in-bst/1",
    "approach": "it node is present then its the ceil, or the closest max to that node (parent) will be its ceil",
    "pseudo_code": "FUNCTION findCeil(node, x):\nans = -1\n\nWHILE node is not NULL:\nIF node.data is equal to x:\nRETURN x\n\nIF node.data is greater than x:\nans = node.data\nnode = node.left\nELSE:\nnode = node.right\n\nRETURN ans"
  },
  {
    "sign_no": 280,
    "question": "Given a binary search tree and an integer.Find the floor value of a key in a binary search tree .\n(If k lies in BST then is floor equal to k,else floor is equal to previous greater value) Note: k would never be less than the minimum element of tree. ",
    "name": "Floor in a Binary Search Tree",
    "topic": "bst",
    "level": "easy",
    "url": "https://bit.ly/3TSbXXE",
    "approach": "similer to prev problem, just have to take the left element that will be our prev greater (floor)",
    "pseudo_code": "FUNCTION Floor(node, input):\nans = -1\n\nWHILE node is not NULL:\nIF node.data is equal to input:\nRETURN input\n\nELSE IF node.data is less than input:\nans = node.data\nnode = node.right\nELSE:\nnode = node.left\n\nRETURN ans"
  },
  {
    "sign_no": 281,
    "question": "You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.\n\nNotice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.",
    "name": "Insert a given Node in Binary Search Tree",
    "topic": "bst",
    "level": "easy",
    "url": "https://leetcode.com/problems/insert-into-a-binary-search-tree/",
    "approach": "To insert the val we can go the the place comparing the val to the node, if val is small then go to nodes left and if greater then go to nodes right. and get the last node in a val and put the new node to its left or right accordingly.",
    "pseudo_code": "FUNCTION insertIntoBST(root, val):\nnew_node = CREATE A NEW TreeNode WITH VALUE val\n\nIF root is NULL:\nRETURN new_node\n\ntemp = root\nprev = NULL\n\nWHILE temp is not NULL:\nprev = temp\nIF val is greater than temp.val:\ntemp = temp.right\nELSE:\ntemp = temp.left\n\nIF prev.val is greater than val:\nprev.left = new_node\nELSE:\nprev.right = new_node\n\nRETURN root"
  },
  {
    "sign_no": 282,
    "question": "Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.\n\nBasically, the deletion can be divided into two stages:\n\nSearch for a node to remove.\nIf the node is found, delete the node.",
    "name": "Delete a Node in Binary Search Tree",
    "topic": "bst",
    "level": "medium",
    "url": "https://leetcode.com/problems/delete-node-in-a-bst/",
    "approach": "there are two ways to delete the node\n\n1. the right subtree of the node will always be greater then its all left elements..so we can detach that subtree and add it to the end of the left's right most node.\n\n2. we can make the right one node and attach all the left nodes to the right's left most node.",
    "pseudo_code": "FUNCTION deleteNode(root, key):\nIF root is NULL:\nRETURN root\n\nIF root.val is equal to key:\nRETURN helper(root)\n\ntemp = root\nWHILE temp is not NULL:\nIF temp.val is greater than key:\nIF temp.left is not NULL and temp.left.val is equal to key:\ntemp.left = helper(temp.left)\nBREAK\nELSE:\ntemp = temp.left\nELSE:\nIF temp.right is not NULL and temp.right.val is equal to key:\ntemp.right = helper(temp.right)\nELSE:\ntemp = temp.right\n\nRETURN root\n\nFUNCTION helper(root):\nIF root.left is NULL:\nRETURN root.right\nELSE IF root.right is NULL:\nRETURN root.left\n\nrightPart = root.right\nroot.right = NULL\nlastOne = findLastRight(root.left)\nlastOne.right = rightPart\nRETURN root.left\n\nFUNCTION findLastRight(root):\nWHILE root is not NULL and root.right is not NULL:\nroot = root.right\nRETURN root"
  },
  {
    "sign_no": 283,
    "question": "Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.",
    "name": "Find K-th smallest/largest element in BST",
    "topic": "bst",
    "level": "medium",
    "url": "https://leetcode.com/problems/kth-smallest-element-in-a-bst/",
    "approach": "To find out the kth smallest or largest element we can use the concept of inorder traversing, \nas inorder traversing on BST always gives a sorted list, then we can find out the kth element easily. \n\nto do this widhout using extra space, you can use a counter variable and whenever you visit a node increase the counter and compare it with k .\n\nuse reverse inorder traversal for kth largest value.",
    "pseudo_code": "FUNCTION inorder(root, cnt, k, kthSmallest):\nIF root is NULL OR cnt is greater than or equal to k:\nRETURN\n\ninorder(root.left, cnt, k, kthSmallest)\n\ncnt = cnt + 1\nIF cnt is equal to k:\nkthSmallest = root.val\nRETURN\n\ninorder(root.right, cnt, k, kthSmallest)\n\nRETURN\n\nFUNCTION kthSmallest(root, k):\ncnt = 0\nkthSmallest = INT_MIN\n\ninorder(root, cnt, k, kthSmallest)\n\nRETURN kthSmallest"
  },
  {
    "sign_no": 284,
    "question": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).\n\nA valid BST is defined as follows:\n\nThe left\nsubtree\nof a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.",
    "name": "Check if a tree is a BST or BT",
    "topic": "bst",
    "level": "medium",
    "url": "https://leetcode.com/problems/validate-binary-search-tree/",
    "approach": "Similer to prev, do inorder traversal and store the value in a variable i.e. prev\ncheck if the prev is greater or equal to current if yes then its not bst.",
    "pseudo_code": "FUNCTION inorder(root, cnt, prev, ans):\nIF root is NULL OR ans is false:\nRETURN\n\ninorder(root.left, cnt, prev, ans)\n\ncnt = cnt + 1\nIF cnt is greater than 1 AND prev is greater than or equal to root.val:\nans = false\nRETURN\n\nprev = root.val\n\ninorder(root.right, cnt, prev, ans)\n\nFUNCTION isValidBST(root):\nIF root is NULL:\nRETURN true\n\nprev = INT_MIN\ncnt = 0\nans = true\n\ninorder(root, cnt, prev, ans)\n\nRETURN ans"
  },
  {
    "sign_no": 285,
    "question": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\n\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”",
    "name": "LCA in Binary Search Tree",
    "topic": "bst",
    "level": "medium",
    "url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/",
    "approach": "Similer to question on line 274, LCA of binary tree...",
    "pseudo_code": ""
  },
  {
    "sign_no": 286,
    "question": "Given an array of integers preorder, which represents the preorder traversal of a BST (i.e., binary search tree), construct the tree and return its root.\n\nIt is guaranteed that there is always possible to find a binary search tree with the given requirements for the given test cases.\n\nA binary search tree is a binary tree where for every node, any descendant of Node.left has a value strictly less than Node.val, and any descendant of Node.right has a value strictly greater than Node.val.\n\nA preorder traversal of a binary tree displays the value of the node first, then traverses Node.left, then traverses Node.right.",
    "name": "Construct a BST from a preorder traversal",
    "topic": "bst",
    "level": "medium",
    "url": "https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/",
    "approach": "We have preorder traversal that means the 1st node is our root node,\nwe can traverse the preorder array and insert each node to tree using the BST insert node approach.\n\nhowever there is a optimized way to do this in o(n) tc.\nhow ? here you see\nwe can use the concept of BSt that every node on the left should be small and right should be large so we can mantain a upper bound to see if the current value can be inserted there or not see pseudo code for more detail.",
    "pseudo_code": "FUNCTION bstFromPreorder(preorder):\ni = 0\nRETURN helper(preorder, i, INT_MAX)\n\nFUNCTION helper(preorder, i, limit):\nIF i is equal to the size of preorder OR preorder[i] is greater than limit:\nRETURN NULL\n\nnode = CREATE NEW TreeNode WITH VALUE preorder[i]\ni = i + 1\nnode.left = helper(preorder, i, node.val)\nnode.right = helper(preorder, i, limit)\nRETURN node"
  },
  {
    "sign_no": 287,
    "question": "You have been given a binary search tree of integers with ‘N’ nodes. You are also given 'KEY' which represents data of a node of this tree.\n\n\nYour task is to return the predecessor and successor of the given node in the BST.\n\n\nNote:\n\n1. The predecessor of a node in BST is that node that will be visited just before the given node in the inorder traversal of the tree. If the given node is visited first in the inorder traversal, then its predecessor is NULL.\n\n2. The successor of a node in BST is that node that will be visited immediately after the given node in the inorder traversal of the tree. If the given node is visited last in the inorder traversal, then its successor is NULL.\n\n3. The node for which predecessor and successor are to be found will always be present in the given tree.\n\n4. A binary search tree (BST) is a binary tree data structure which has the following properties.\n• The left subtree of a node contains only nodes with data less than the node’s data.\n• The right subtree of a node contains only nodes with data greater than the node’s data.\n• Both the left and right subtrees must also be binary search trees.",
    "name": "Inorder Successor/Predecessor in BST",
    "topic": "bst",
    "level": "medium",
    "url": "https://leetcode.com/problems/inorder-successor-in-bst/",
    "approach": "we have a BST, to find the succ and predcce....\n1. we can get the inorder traversal array and find the key then we can get the succ and pred...\nthe algo will take much more time and to optimize it we have a 2nd algo...\n\n2. we know that we can find the key in BST in o(H) wehre h is height of tree...\nso the pred will be the closest smaller value then the key and the succ will be closest greater then the key...",
    "pseudo_code": "FUNCTION predecessorSuccessor(root, key):\nsucc = -1\npred = -1\ntemp = root\n\n// Find the successor\nWHILE root is not NULL:\nIF root.data is less than or equal to key:\nroot = root.right\nELSE:\nsucc = root.data\nroot = root.left\n\nroot = temp\n\n// Find the predecessor\nWHILE root is not NULL:\nIF root.data is greater than or equal to key:\nroot = root.left\nELSE:\npred = root.data\nroot = root.right\n\nRETURN (pred, succ)"
  },
  {
    "sign_no": 288,
    "question": "Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):\n\nBSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.\nboolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.\nint next() Moves the pointer to the right, then returns the number at the pointer.\n\nNotice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST.\n\nYou may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called.",
    "name": "Merge 2 BST's",
    "topic": "bst",
    "level": "hard",
    "url": "https://leetcode.com/problems/binary-search-tree-iterator/",
    "approach": "given the root node, have to implement the iterator class..can be down using an vector and a index to store and iterate the bst inorder traversal...\n\nhowver we have to use only o(H) extra space...and to do that we have to use a stack that will get updated on every iteration using partial inorder traversal...",
    "pseudo_code": "CLASS BSTIterator:\nCONSTRUCTOR(root):\ninorder(root)\n\nFUNCTION inorder(root):\nWHILE root is not NULL:\nPUSH root to s\nroot = root.left\n\nFUNCTION next():\ntop = s.top()\ns.pop()\ninorder(top.right)\nRETURN top.val\n\nFUNCTION hasNext():\nIF s is not empty:\nRETURN true\nELSE:\nRETURN false"
  },
  {
    "sign_no": 289,
    "question": "Given the root of a binary search tree and an integer k, return true if there exist two elements in the BST such that their sum is equal to k, or false otherwise.",
    "name": "Two Sum In BST | Check if there exists a pair with Sum K",
    "topic": "bst",
    "level": "medium",
    "url": "https://leetcode.com/problems/two-sum-iv-input-is-a-bst/",
    "approach": "can be done using a unordered map as we will store each element by inorder traversal...\nhowever this is not optimal....\n\nusing the concept for BST iterator as perv problem...we can implement the traversal with better time complexity and better space complexity.",
    "pseudo_code": "#Naive Approact\n\nFUNCTION ino(root):\nIF root is NULL:\nRETURN\n\nino(root.left)\nINCREMENT mp[root.val]\nino(root.right)\n\nFUNCTION findTarget(root, k):\nmp = an empty map\nino(root)\n\nFOR each key-value pair (num, count) in mp:\nrem = k - num\nIF rem is not equal to num AND rem exists in mp:\nRETURN true\n\nRETURN false\n\n# Optimal Approach\nCLASS BSTIterator:\nCONSTRUCTOR(root, isRev):\nreverse = isRev\npushAll(root)\n\nFUNCTION hasNext():\nRETURN NOT s.empty()\n\nFUNCTION next():\ntop = s.top()\ns.pop()\nIF NOT reverse:\npushAll(top.right)\nELSE:\npushAll(top.left)\nRETURN top.val\n\nFUNCTION pushAll(node):\nWHILE node is not NULL:\nPUSH node to s\nIF reverse:\nnode = node.right\nELSE:\nnode = node.left\n\nCLASS Solution:\nFUNCTION findTarget(root, k):\nIF root is NULL:\nRETURN false\n\nl = NEW BSTIterator(root, false)\nr = NEW BSTIterator(root, true)\ni = l.next()\nj = r.next()\n\nWHILE i is less than j:\nIF i + j is equal to k:\nRETURN true\nELSE IF i + j is less than k:\ni = l.next()\nELSE:\nj = r.next()\n\nRETURN false"
  }
]